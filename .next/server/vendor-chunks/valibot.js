"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot";
exports.ids = ["vendor-chunks/valibot"];
exports.modules = {

/***/ "(ssr)/../../node_modules/valibot/dist/index.js":
/*!************************************************!*\
  !*** ../../node_modules/valibot/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE64_REGEX: () => (/* binding */ BASE64_REGEX),\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   DIGITS_REGEX: () => (/* binding */ DIGITS_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   IP_REGEX: () => (/* binding */ IP_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   MAC_REGEX: () => (/* binding */ MAC_REGEX),\n/* harmony export */   NANO_ID_REGEX: () => (/* binding */ NANO_ID_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   RFC_EMAIL_REGEX: () => (/* binding */ RFC_EMAIL_REGEX),\n/* harmony export */   SLUG_REGEX: () => (/* binding */ SLUG_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   _addIssue: () => (/* binding */ _addIssue),\n/* harmony export */   _getByteCount: () => (/* binding */ _getByteCount),\n/* harmony export */   _getGraphemeCount: () => (/* binding */ _getGraphemeCount),\n/* harmony export */   _getStandardProps: () => (/* binding */ _getStandardProps),\n/* harmony export */   _getWordCount: () => (/* binding */ _getWordCount),\n/* harmony export */   _isLuhnAlgo: () => (/* binding */ _isLuhnAlgo),\n/* harmony export */   _isValidObjectKey: () => (/* binding */ _isValidObjectKey),\n/* harmony export */   _joinExpects: () => (/* binding */ _joinExpects),\n/* harmony export */   _stringify: () => (/* binding */ _stringify),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   args: () => (/* binding */ args),\n/* harmony export */   argsAsync: () => (/* binding */ argsAsync),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   awaitAsync: () => (/* binding */ awaitAsync),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   check: () => (/* binding */ check),\n/* harmony export */   checkAsync: () => (/* binding */ checkAsync),\n/* harmony export */   checkItems: () => (/* binding */ checkItems),\n/* harmony export */   checkItemsAsync: () => (/* binding */ checkItemsAsync),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   deleteGlobalConfig: () => (/* binding */ deleteGlobalConfig),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   deleteSchemaMessage: () => (/* binding */ deleteSchemaMessage),\n/* harmony export */   deleteSpecificMessage: () => (/* binding */ deleteSpecificMessage),\n/* harmony export */   description: () => (/* binding */ description),\n/* harmony export */   digits: () => (/* binding */ digits),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   entriesFromList: () => (/* binding */ entriesFromList),\n/* harmony export */   entriesFromObjects: () => (/* binding */ entriesFromObjects),\n/* harmony export */   \"enum\": () => (/* binding */ enum_),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   everyItem: () => (/* binding */ everyItem),\n/* harmony export */   exactOptional: () => (/* binding */ exactOptional),\n/* harmony export */   exactOptionalAsync: () => (/* binding */ exactOptionalAsync),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   file: () => (/* binding */ file),\n/* harmony export */   filterItems: () => (/* binding */ filterItems),\n/* harmony export */   findItem: () => (/* binding */ findItem),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   forwardAsync: () => (/* binding */ forwardAsync),\n/* harmony export */   \"function\": () => (/* binding */ function_),\n/* harmony export */   function_: () => (/* binding */ function_),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getDotPath: () => (/* binding */ getDotPath),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   getGlobalMessage: () => (/* binding */ getGlobalMessage),\n/* harmony export */   getSchemaMessage: () => (/* binding */ getSchemaMessage),\n/* harmony export */   getSpecificMessage: () => (/* binding */ getSpecificMessage),\n/* harmony export */   graphemes: () => (/* binding */ graphemes),\n/* harmony export */   gtValue: () => (/* binding */ gtValue),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersectAsync: () => (/* binding */ intersectAsync),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isOfKind: () => (/* binding */ isOfKind),\n/* harmony export */   isOfType: () => (/* binding */ isOfType),\n/* harmony export */   isValiError: () => (/* binding */ isValiError),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   lazyAsync: () => (/* binding */ lazyAsync),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   looseObject: () => (/* binding */ looseObject),\n/* harmony export */   looseObjectAsync: () => (/* binding */ looseObjectAsync),\n/* harmony export */   looseTuple: () => (/* binding */ looseTuple),\n/* harmony export */   looseTupleAsync: () => (/* binding */ looseTupleAsync),\n/* harmony export */   ltValue: () => (/* binding */ ltValue),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   mapItems: () => (/* binding */ mapItems),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxGraphemes: () => (/* binding */ maxGraphemes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   maxWords: () => (/* binding */ maxWords),\n/* harmony export */   metadata: () => (/* binding */ metadata),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minGraphemes: () => (/* binding */ minGraphemes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   minWords: () => (/* binding */ minWords),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonEmpty: () => (/* binding */ nonEmpty),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notGraphemes: () => (/* binding */ notGraphemes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   notValues: () => (/* binding */ notValues),\n/* harmony export */   notWords: () => (/* binding */ notWords),\n/* harmony export */   \"null\": () => (/* binding */ null_),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   objectWithRest: () => (/* binding */ objectWithRest),\n/* harmony export */   objectWithRestAsync: () => (/* binding */ objectWithRestAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   parserAsync: () => (/* binding */ parserAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   partialCheck: () => (/* binding */ partialCheck),\n/* harmony export */   partialCheckAsync: () => (/* binding */ partialCheckAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   pipeAsync: () => (/* binding */ pipeAsync),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   rawCheck: () => (/* binding */ rawCheck),\n/* harmony export */   rawCheckAsync: () => (/* binding */ rawCheckAsync),\n/* harmony export */   rawTransform: () => (/* binding */ rawTransform),\n/* harmony export */   rawTransformAsync: () => (/* binding */ rawTransformAsync),\n/* harmony export */   readonly: () => (/* binding */ readonly),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   reduceItems: () => (/* binding */ reduceItems),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   returns: () => (/* binding */ returns),\n/* harmony export */   returnsAsync: () => (/* binding */ returnsAsync),\n/* harmony export */   rfcEmail: () => (/* binding */ rfcEmail),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   safeParser: () => (/* binding */ safeParser),\n/* harmony export */   safeParserAsync: () => (/* binding */ safeParserAsync),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   setGlobalConfig: () => (/* binding */ setGlobalConfig),\n/* harmony export */   setGlobalMessage: () => (/* binding */ setGlobalMessage),\n/* harmony export */   setSchemaMessage: () => (/* binding */ setSchemaMessage),\n/* harmony export */   setSpecificMessage: () => (/* binding */ setSpecificMessage),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slug: () => (/* binding */ slug),\n/* harmony export */   someItem: () => (/* binding */ someItem),\n/* harmony export */   sortItems: () => (/* binding */ sortItems),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   strictObject: () => (/* binding */ strictObject),\n/* harmony export */   strictObjectAsync: () => (/* binding */ strictObjectAsync),\n/* harmony export */   strictTuple: () => (/* binding */ strictTuple),\n/* harmony export */   strictTupleAsync: () => (/* binding */ strictTupleAsync),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   title: () => (/* binding */ title),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   trim: () => (/* binding */ trim),\n/* harmony export */   trimEnd: () => (/* binding */ trimEnd),\n/* harmony export */   trimStart: () => (/* binding */ trimStart),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   tupleWithRest: () => (/* binding */ tupleWithRest),\n/* harmony export */   tupleWithRestAsync: () => (/* binding */ tupleWithRestAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefined: () => (/* binding */ undefined_),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   undefinedable: () => (/* binding */ undefinedable),\n/* harmony export */   undefinedableAsync: () => (/* binding */ undefinedableAsync),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   values: () => (/* binding */ values),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   void_: () => (/* binding */ void_),\n/* harmony export */   words: () => (/* binding */ words)\n/* harmony export */ });\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\n// @__NO_SIDE_EFFECTS__\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\n// @__NO_SIDE_EFFECTS__\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message !== void 0) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_getByteCount/_getByteCount.ts\nvar textEncoder;\n// @__NO_SIDE_EFFECTS__\nfunction _getByteCount(input) {\n  if (!textEncoder) {\n    textEncoder = new TextEncoder();\n  }\n  return textEncoder.encode(input).length;\n}\n\n// src/utils/_getGraphemeCount/_getGraphemeCount.ts\nvar segmenter;\n// @__NO_SIDE_EFFECTS__\nfunction _getGraphemeCount(input) {\n  if (!segmenter) {\n    segmenter = new Intl.Segmenter();\n  }\n  const segments = segmenter.segment(input);\n  let count = 0;\n  for (const _ of segments) {\n    count++;\n  }\n  return count;\n}\n\n// src/utils/_getStandardProps/_getStandardProps.ts\n// @__NO_SIDE_EFFECTS__\nfunction _getStandardProps(context) {\n  return {\n    version: 1,\n    vendor: \"valibot\",\n    validate(value2) {\n      return context[\"~run\"]({ value: value2 }, getGlobalConfig());\n    }\n  };\n}\n\n// src/utils/_getWordCount/_getWordCount.ts\nvar store5;\n// @__NO_SIDE_EFFECTS__\nfunction _getWordCount(locales, input) {\n  if (!store5) {\n    store5 = /* @__PURE__ */ new Map();\n  }\n  if (!store5.get(locales)) {\n    store5.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n  }\n  const segments = store5.get(locales).segment(input);\n  let count = 0;\n  for (const segment of segments) {\n    if (segment.isWordLike) {\n      count++;\n    }\n  }\n  return count;\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\n// @__NO_SIDE_EFFECTS__\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\n// @__NO_SIDE_EFFECTS__\nfunction _joinExpects(values2, separator) {\n  const list = [...new Set(values2)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/entriesFromObjects/entriesFromObjects.ts\n// @__NO_SIDE_EFFECTS__\nfunction entriesFromObjects(schemas) {\n  const entries = {};\n  for (const schema of schemas) {\n    Object.assign(entries, schema.entries);\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\n// @__NO_SIDE_EFFECTS__\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\n// @__NO_SIDE_EFFECTS__\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/args/args.ts\n// @__NO_SIDE_EFFECTS__\nfunction args(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: args,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const argsDataset = this.schema[\"~run\"]({ value: args_ }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/args/argsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction argsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"args\",\n    reference: argsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args2) => {\n        const argsDataset = await schema[\"~run\"]({ value: args2 }, config2);\n        if (argsDataset.issues) {\n          throw new ValiError(argsDataset.issues);\n        }\n        return func(...argsDataset.value);\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/await/awaitAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async \"~run\"(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\nvar RFC_EMAIL_REGEX = (\n  // eslint-disable-next-line regexp/prefer-w, no-useless-escape, regexp/no-useless-escape, regexp/require-unicode-regexp\n  /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n);\nvar SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/actions/base64/base64.ts\n// @__NO_SIDE_EFFECTS__\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\n// @__NO_SIDE_EFFECTS__\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\n// @__NO_SIDE_EFFECTS__\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\n// @__NO_SIDE_EFFECTS__\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItemsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction checkItemsAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItemsAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const requirementResults = await Promise.all(\n          dataset.value.map(this.requirement)\n        );\n        for (let index = 0; index < dataset.value.length; index++) {\n          if (!requirementResults[index]) {\n            const item = dataset.value[index];\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  // eslint-disable-next-line redos-detector/no-unsafe-regex\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\n// @__NO_SIDE_EFFECTS__\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\n// @__NO_SIDE_EFFECTS__\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\n// @__NO_SIDE_EFFECTS__\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\n// @__NO_SIDE_EFFECTS__\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\n// @__NO_SIDE_EFFECTS__\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\n// @__NO_SIDE_EFFECTS__\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\n// @__NO_SIDE_EFFECTS__\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\n// @__NO_SIDE_EFFECTS__\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\n// @__NO_SIDE_EFFECTS__\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/graphemes/graphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction graphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"graphemes\",\n    reference: graphemes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/gtValue/gtValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction gtValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"gt_value\",\n    reference: gtValue,\n    async: false,\n    expects: `>${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value > this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\n// @__NO_SIDE_EFFECTS__\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\n// @__NO_SIDE_EFFECTS__\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\n// @__NO_SIDE_EFFECTS__\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\n// @__NO_SIDE_EFFECTS__\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\n// @__NO_SIDE_EFFECTS__\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\n// @__NO_SIDE_EFFECTS__\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\n// @__NO_SIDE_EFFECTS__\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\n// @__NO_SIDE_EFFECTS__\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\n// @__NO_SIDE_EFFECTS__\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ltValue/ltValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction ltValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"lt_value\",\n    reference: ltValue,\n    async: false,\n    expects: `<${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value < this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\n// @__NO_SIDE_EFFECTS__\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxGraphemes/maxGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_graphemes\",\n    reference: maxGraphemes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value <= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxWords/maxWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction maxWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_words\",\n    reference: maxWords,\n    async: false,\n    expects: `<=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count > this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\n// @__NO_SIDE_EFFECTS__\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\n// @__NO_SIDE_EFFECTS__\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minGraphemes/minGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction minGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_graphemes\",\n    reference: minGraphemes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(dataset.value >= this.requirement)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minWords/minWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction minWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_words\",\n    reference: minWords,\n    async: false,\n    expects: `>=${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count < this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\n// @__NO_SIDE_EFFECTS__\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\n// @__NO_SIDE_EFFECTS__\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\n// @__NO_SIDE_EFFECTS__\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = _getByteCount(dataset.value);\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notGraphemes/notGraphemes.ts\n// @__NO_SIDE_EFFECTS__\nfunction notGraphemes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_graphemes\",\n    reference: notGraphemes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getGraphemeCount(dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"graphemes\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\n// @__NO_SIDE_EFFECTS__\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\n// @__NO_SIDE_EFFECTS__\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValues/notValues.ts\n// @__NO_SIDE_EFFECTS__\nfunction notValues(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_values\",\n    reference: notValues,\n    async: false,\n    expects: `!${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notWords/notWords.ts\n// @__NO_SIDE_EFFECTS__\nfunction notWords(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_words\",\n    reference: notWords,\n    async: false,\n    expects: `!${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count === this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\n// @__NO_SIDE_EFFECTS__\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n// @__NO_SIDE_EFFECTS__\nfunction _isPartiallyTyped(dataset, paths) {\n  if (dataset.issues) {\n    for (const path of paths) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (\n            // @ts-expect-error\n            path[index] !== issue.path[index].key && // @ts-expect-error\n            (path[index] !== \"$\" || issue.path[index].type !== \"array\")\n          ) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheck(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialCheckAsync(paths, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    paths,\n    requirement,\n    message,\n    async \"~run\"(dataset, config2) {\n      if ((dataset.typed || _isPartiallyTyped(dataset, paths)) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    \"~run\"(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async \"~run\"(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    \"~run\"(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\n// @__NO_SIDE_EFFECTS__\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    \"~run\"(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\n// @__NO_SIDE_EFFECTS__\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returns.ts\n// @__NO_SIDE_EFFECTS__\nfunction returns(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returns,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = (...args_) => {\n        const returnsDataset = this.schema[\"~run\"](\n          { value: func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/returns/returnsAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction returnsAsync(schema) {\n  return {\n    kind: \"transformation\",\n    type: \"returns\",\n    reference: returnsAsync,\n    async: false,\n    schema,\n    \"~run\"(dataset, config2) {\n      const func = dataset.value;\n      dataset.value = async (...args_) => {\n        const returnsDataset = await this.schema[\"~run\"](\n          { value: await func(...args_) },\n          config2\n        );\n        if (returnsDataset.issues) {\n          throw new ValiError(returnsDataset.issues);\n        }\n        return returnsDataset.value;\n      };\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rfcEmail/rfcEmail.ts\n// @__NO_SIDE_EFFECTS__\nfunction rfcEmail(message) {\n  return {\n    kind: \"validation\",\n    type: \"rfc_email\",\n    reference: rfcEmail,\n    expects: null,\n    async: false,\n    requirement: RFC_EMAIL_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\n// @__NO_SIDE_EFFECTS__\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/slug/slug.ts\n// @__NO_SIDE_EFFECTS__\nfunction slug(message) {\n  return {\n    kind: \"validation\",\n    type: \"slug\",\n    reference: slug,\n    async: false,\n    expects: null,\n    requirement: SLUG_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"slug\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\n// @__NO_SIDE_EFFECTS__\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\n// @__NO_SIDE_EFFECTS__\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\n// @__NO_SIDE_EFFECTS__\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\n// @__NO_SIDE_EFFECTS__\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\n// @__NO_SIDE_EFFECTS__\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\n// @__NO_SIDE_EFFECTS__\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\n// @__NO_SIDE_EFFECTS__\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    \"~run\"(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async \"~run\"(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\n// @__NO_SIDE_EFFECTS__\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\n// @__NO_SIDE_EFFECTS__\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    \"~run\"(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\n// @__NO_SIDE_EFFECTS__\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\n// @__NO_SIDE_EFFECTS__\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\n// @__NO_SIDE_EFFECTS__\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\n// @__NO_SIDE_EFFECTS__\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/values/values.ts\n// @__NO_SIDE_EFFECTS__\nfunction values(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"values\",\n    reference: values,\n    async: false,\n    expects: `${_joinExpects(\n      requirement.map(\n        (value2) => value2 instanceof Date ? value2.toJSON() : _stringify(value2)\n      ),\n      \"|\"\n    )}`,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed && !this.requirement.some(\n        (value2) => value2 <= dataset.value && value2 >= dataset.value\n      )) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/words/words.ts\n// @__NO_SIDE_EFFECTS__\nfunction words(locales, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"words\",\n    reference: words,\n    async: false,\n    expects: `${requirement}`,\n    locales,\n    requirement,\n    message,\n    \"~run\"(dataset, config2) {\n      if (dataset.typed) {\n        const count = _getWordCount(this.locales, dataset.value);\n        if (count !== this.requirement) {\n          _addIssue(this, \"words\", dataset, config2, {\n            received: `${count}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/assert/assert.ts\nfunction assert(schema, input) {\n  const issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n  if (issues) {\n    throw new ValiError(issues);\n  }\n}\n\n// src/methods/config/config.ts\n// @__NO_SIDE_EFFECTS__\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config_) {\n      return schema[\"~run\"](dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const outputDataset = schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const outputDataset = await schema[\"~run\"](dataset, config2);\n      return outputDataset.issues ? {\n        typed: true,\n        value: await getFallback(this, outputDataset, config2)\n      } : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\n// @__NO_SIDE_EFFECTS__\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\n// @__NO_SIDE_EFFECTS__\nfunction forward(action, path) {\n  return {\n    ...action,\n    \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction forwardAsync(action, path) {\n  return {\n    ...action,\n    async: true,\n    async \"~run\"(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      dataset = await action[\"~run\"](dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of path) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\n// @__NO_SIDE_EFFECTS__\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\n// @__NO_SIDE_EFFECTS__\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await /* @__PURE__ */ getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\n// @__NO_SIDE_EFFECTS__\nfunction is(schema, input) {\n  return !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\n// @__NO_SIDE_EFFECTS__\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\n// @__NO_SIDE_EFFECTS__\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item[\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item[\"~run\"]({ value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\n// @__NO_SIDE_EFFECTS__\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\n// @__NO_SIDE_EFFECTS__\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\n// @__NO_SIDE_EFFECTS__\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\n// @__NO_SIDE_EFFECTS__\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\n// @__NO_SIDE_EFFECTS__\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\n// @__NO_SIDE_EFFECTS__\nfunction enum_(enum__, message) {\n  const options = [];\n  for (const key in enum__) {\n    if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) {\n      options.push(enum__[key]);\n    }\n  }\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptional,\n    expects: wrapped.expects,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/exactOptional/exactOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction exactOptionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"exact_optional\",\n    reference: exactOptionalAsync,\n    expects: wrapped.expects,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/file/file.ts\n// @__NO_SIDE_EFFECTS__\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\n// @__NO_SIDE_EFFECTS__\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\n// @__NO_SIDE_EFFECTS__\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\n// @__NO_SIDE_EFFECTS__\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema[\"~run\"]({ value: input }, config2);\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map((schema) => schema[\"~run\"]({ value: input }, config2))\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      return this.getter(dataset.value)[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      return (await this.getter(dataset.value))[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\n// @__NO_SIDE_EFFECTS__\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\n// @__NO_SIDE_EFFECTS__\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key[\"~run\"]({ value: inputKey }, config2);\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key[\"~run\"]({ value: inputKey }, config2),\n              this.value[\"~run\"]({ value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\n// @__NO_SIDE_EFFECTS__\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\n// @__NO_SIDE_EFFECTS__\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== null) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (!(dataset.value === null || dataset.value === void 0)) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value !== void 0) {\n        dataset = await this.wrapped[\"~run\"](dataset, config2);\n      }\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/null/null.ts\n// @__NO_SIDE_EFFECTS__\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullish(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction nullishAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/number/number.ts\n// @__NO_SIDE_EFFECTS__\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\n// @__NO_SIDE_EFFECTS__\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const valueDataset = this.rest[\"~run\"](\n                // @ts-expect-error\n                { value: input[key] },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // If key is present or its an optional schema with a default value,\n          // parse input of key or default value asynchronously\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, valueSchema]) => {\n              if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n              valueSchema.default !== void 0) {\n                const value2 = key in input ? (\n                  // @ts-expect-error\n                  input[key]\n                ) : await getDefault(valueSchema);\n                return [\n                  key,\n                  value2,\n                  valueSchema,\n                  await valueSchema[\"~run\"]({ value: value2 }, config2)\n                ];\n              }\n              return [\n                key,\n                // @ts-expect-error\n                input[key],\n                valueSchema,\n                null\n              ];\n            })\n          ),\n          // Parse other entries with rest schema asynchronously\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueSchema, valueDataset] of normalDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\n// @__NO_SIDE_EFFECTS__\nfunction optional(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction optionalAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\n// @__NO_SIDE_EFFECTS__\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\n// @__NO_SIDE_EFFECTS__\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\n// @__NO_SIDE_EFFECTS__\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key[\"~run\"]({ value: entryKey }, config2);\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value[\"~run\"](\n              { value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key[\"~run\"]({ value: entryKey }, config2),\n              this.value[\"~run\"]({ value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\n// @__NO_SIDE_EFFECTS__\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value[\"~run\"](\n            { value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value[\"~run\"]({ value: inputValue }, config2)\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const valueSchema = this.entries[key];\n          if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n          valueSchema.default !== void 0) {\n            const value2 = key in input ? (\n              // @ts-expect-error\n              input[key]\n            ) : getDefault(valueSchema);\n            const valueDataset = valueSchema[\"~run\"]({ value: value2 }, config2);\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  // @ts-expect-error\n                  value: input[key]\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, valueSchema]) => {\n            if (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && // @ts-expect-error\n            valueSchema.default !== void 0) {\n              const value2 = key in input ? (\n                // @ts-expect-error\n                input[key]\n              ) : await getDefault(valueSchema);\n              return [\n                key,\n                value2,\n                valueSchema,\n                await valueSchema[\"~run\"]({ value: value2 }, config2)\n              ];\n            }\n            return [\n              key,\n              // @ts-expect-error\n              input[key],\n              valueSchema,\n              null\n            ];\n          })\n        );\n        for (const [key, value2, valueSchema, valueDataset] of valueDatasets) {\n          if (valueDataset) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          } else if (valueSchema.fallback !== void 0) {\n            dataset.value[key] = await getFallback(valueSchema);\n          } else if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n            _addIssue(this, \"key\", dataset, config2, {\n              input: void 0,\n              expected: `\"${key}\"`,\n              path: [\n                {\n                  type: \"object\",\n                  origin: \"key\",\n                  input,\n                  key,\n                  value: value2\n                }\n              ]\n            });\n            if (config2.abortEarly) {\n              break;\n            }\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              _addIssue(this, \"key\", dataset, config2, {\n                input: key,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"key\",\n                    input,\n                    key,\n                    // @ts-expect-error\n                    value: input[key]\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          _addIssue(this, \"type\", dataset, config2, {\n            input: input[this.items.length],\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: input[this.items.length]\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\n// @__NO_SIDE_EFFECTS__\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\n// @__NO_SIDE_EFFECTS__\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\n// @__NO_SIDE_EFFECTS__\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [key, value2, await item[\"~run\"]({ value: value2 }, config2)];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key][\"~run\"]({ value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest[\"~run\"]({ value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest[\"~run\"]({ value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedable(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction undefinedableAsync(wrapped, default_) {\n  return {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    default: default_,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (this.default !== void 0) {\n          dataset.value = await getDefault(this, dataset, config2);\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped[\"~run\"](dataset, config2);\n    }\n  };\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\n// @__NO_SIDE_EFFECTS__\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\n// @__NO_SIDE_EFFECTS__\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema[\"~run\"]({ value: dataset.value }, config2);\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema[\"~run\"](\n          { value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\n// @__NO_SIDE_EFFECTS__\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\n// @__NO_SIDE_EFFECTS__\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema[\"~run\"]({ value: input }, config2);\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                const discriminatorSchema = schema.entries[currentKey];\n                if (currentKey in input ? (await discriminatorSchema[\"~run\"](\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema[\"~run\"](\n                  { value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\n// @__NO_SIDE_EFFECTS__\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\n// @__NO_SIDE_EFFECTS__\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\n// @__NO_SIDE_EFFECTS__\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\n// @__NO_SIDE_EFFECTS__\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\n// @__NO_SIDE_EFFECTS__\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/partial/partialAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\n// @__NO_SIDE_EFFECTS__\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/pipe/pipe.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    },\n    async \"~run\"(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item[\"~run\"](dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\n// @__NO_SIDE_EFFECTS__\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/required/requiredAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return {\n    ...schema,\n    entries,\n    get \"~standard\"() {\n      return _getStandardProps(this);\n    }\n  };\n}\n\n// src/methods/safeParse/safeParse.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParse(schema, input, config2) {\n  const dataset = schema[\"~run\"]({ value: input }, getGlobalConfig(config2));\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\n// @__NO_SIDE_EFFECTS__\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema[\"~run\"](\n    { value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\n// @__NO_SIDE_EFFECTS__\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\n// @__NO_SIDE_EFFECTS__\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3ZhbGlib3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNLElBQUksdUJBQXVCLFVBQVUsYUFBYSxVQUFVLFNBQVM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYyxXQUFXLEdBQUc7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUU7QUFDcEUsd0JBQXdCLEVBQUUsY0FBYyxFQUFFLFdBQVcsRUFBRTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsR0FBRztBQUM5RTtBQUNBO0FBQ0EsV0FBVyxNQUFNLElBQUksTUFBTSxFQUFFLEVBQUUsSUFBSSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU0sRUFBRSxFQUFFLElBQUksTUFBTSxJQUFJLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxFQUFFLElBQUksR0FBRyxNQUFNLE9BQU8sTUFBTSxpQkFBaUIsb0JBQW9CLEdBQUcsZUFBZSxLQUFLLG1CQUFtQixnQkFBZ0IsTUFBTSxpQkFBaUIsb0JBQW9CLEdBQUcsZUFBZSxLQUFLLG1CQUFtQjtBQUN4VDtBQUNBO0FBQ0EsdUNBQXVDLElBQUksWUFBWSxFQUFFLFlBQVksRUFBRTtBQUN2RSxzQkFBc0IsR0FBRyxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUM3QztBQUNBO0FBQ0EsaUZBQWlGLEVBQUU7QUFDbkY7QUFDQSxpQ0FBaUMsSUFBSSxHQUFHLEVBQUUsUUFBUSxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLEVBQUUsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxFQUFFLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLFNBQVMsSUFBSSxhQUFhLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLEVBQUUsSUFBSSxxQkFBcUIsSUFBSSxFQUFFLElBQUksaUJBQWlCLEVBQUUsTUFBTSxJQUFJLDBDQUEwQyxFQUFFLDBDQUEwQyxJQUFJLEdBQUcsSUFBSSxzQ0FBc0MsRUFBRTtBQUMxaUIsOEZBQThGLEVBQUUsaUJBQWlCLElBQUksR0FBRyxFQUFFLFFBQVEsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLGFBQWEsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLEVBQUUsSUFBSSxZQUFZLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxFQUFFLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxZQUFZLElBQUksRUFBRSxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLEVBQUUsSUFBSSxTQUFTLElBQUksYUFBYSxJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSxFQUFFLElBQUkscUJBQXFCLElBQUksRUFBRSxJQUFJLGlCQUFpQixFQUFFLE1BQU0sSUFBSSwwQ0FBMEMsRUFBRSwwQ0FBMEMsSUFBSSxHQUFHLElBQUksc0NBQXNDLEVBQUU7QUFDMW5CLDBCQUEwQixFQUFFO0FBQzVCLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0EsNkRBQTZELEVBQUU7QUFDL0QsK0JBQStCLEVBQUUsNkVBQTZFLEVBQUUsUUFBUSxJQUFJO0FBQzVILDBCQUEwQixFQUFFO0FBQzVCLCtCQUErQixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUU7QUFDL0csK0JBQStCLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRTtBQUM5SSw2QkFBNkIsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUUsZ0NBQWdDLEtBQUssNkNBQTZDLEtBQUs7QUFDeEg7QUFDQTtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JELDJCQUEyQixFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUUsU0FBUyxHQUFHOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxNQUFNLElBQUksRUFBRSxPQUFPLElBQUksRUFBRSxJQUFJLElBQUksRUFBRSxPQUFPLElBQUksRUFBRSxJQUFJO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQSxnQkFBZ0IsRUFBRSxJQUFJLE1BQU07QUFDNUI7QUFDQSxzQkFBc0IsRUFBRSxJQUFJLEdBQUc7QUFDL0I7QUFDQTtBQUNBLGFBQWEsRUFBRSw2QkFBNkIsRUFBRSxrQkFBa0IsR0FBRztBQUNuRTtBQUNBLGVBQWUsTUFBTSxNQUFNLE1BQU07QUFDakM7QUFDQSxRQUFRLEdBQUcsTUFBTSxJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUE4QztBQUN0RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkVBQTZFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRSxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2RUFBNkU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkVBQTZFO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2RUFBNkU7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUJBQXFCLFFBQVEsd0JBQXdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBZ0Q7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLElBQUksa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsZ0VBQWdFO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWMsSUFBSSxrQkFBa0I7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxjQUFjO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0JBQW9CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRCxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsbUNBQW1DLG1CQUFtQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsbUJBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRCQUE0QixJQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGVBQWU7QUFDckUsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGNBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sY0FBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrUkUiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xc0JzQsNGA0LjQvdC+0YfQutCwXFxEb3dubG9hZHNcXGJheWhhbi1taW5pYXBwLW1haW5cXG5vZGVfbW9kdWxlc1xcdmFsaWJvdFxcZGlzdFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3N0b3JhZ2VzL2dsb2JhbENvbmZpZy9nbG9iYWxDb25maWcudHNcbnZhciBzdG9yZTtcbmZ1bmN0aW9uIHNldEdsb2JhbENvbmZpZyhjb25maWcyKSB7XG4gIHN0b3JlID0geyAuLi5zdG9yZSwgLi4uY29uZmlnMiB9O1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGdldEdsb2JhbENvbmZpZyhjb25maWcyKSB7XG4gIHJldHVybiB7XG4gICAgbGFuZzogY29uZmlnMj8ubGFuZyA/PyBzdG9yZT8ubGFuZyxcbiAgICBtZXNzYWdlOiBjb25maWcyPy5tZXNzYWdlLFxuICAgIGFib3J0RWFybHk6IGNvbmZpZzI/LmFib3J0RWFybHkgPz8gc3RvcmU/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZzI/LmFib3J0UGlwZUVhcmx5ID8/IHN0b3JlPy5hYm9ydFBpcGVFYXJseVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlR2xvYmFsQ29uZmlnKCkge1xuICBzdG9yZSA9IHZvaWQgMDtcbn1cblxuLy8gc3JjL3N0b3JhZ2VzL2dsb2JhbE1lc3NhZ2UvZ2xvYmFsTWVzc2FnZS50c1xudmFyIHN0b3JlMjtcbmZ1bmN0aW9uIHNldEdsb2JhbE1lc3NhZ2UobWVzc2FnZSwgbGFuZykge1xuICBpZiAoIXN0b3JlMikgc3RvcmUyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmUyLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXRHbG9iYWxNZXNzYWdlKGxhbmcpIHtcbiAgcmV0dXJuIHN0b3JlMj8uZ2V0KGxhbmcpO1xufVxuZnVuY3Rpb24gZGVsZXRlR2xvYmFsTWVzc2FnZShsYW5nKSB7XG4gIHN0b3JlMj8uZGVsZXRlKGxhbmcpO1xufVxuXG4vLyBzcmMvc3RvcmFnZXMvc2NoZW1hTWVzc2FnZS9zY2hlbWFNZXNzYWdlLnRzXG52YXIgc3RvcmUzO1xuZnVuY3Rpb24gc2V0U2NoZW1hTWVzc2FnZShtZXNzYWdlLCBsYW5nKSB7XG4gIGlmICghc3RvcmUzKSBzdG9yZTMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdG9yZTMuc2V0KGxhbmcsIG1lc3NhZ2UpO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGdldFNjaGVtYU1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUzPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTY2hlbWFNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUzPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zcGVjaWZpY01lc3NhZ2Uvc3BlY2lmaWNNZXNzYWdlLnRzXG52YXIgc3RvcmU0O1xuZnVuY3Rpb24gc2V0U3BlY2lmaWNNZXNzYWdlKHJlZmVyZW5jZSwgbWVzc2FnZSwgbGFuZykge1xuICBpZiAoIXN0b3JlNCkgc3RvcmU0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgaWYgKCFzdG9yZTQuZ2V0KHJlZmVyZW5jZSkpIHN0b3JlNC5zZXQocmVmZXJlbmNlLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgc3RvcmU0LmdldChyZWZlcmVuY2UpLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXRTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHJldHVybiBzdG9yZTQ/LmdldChyZWZlcmVuY2UpPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHN0b3JlND8uZ2V0KHJlZmVyZW5jZSk/LmRlbGV0ZShsYW5nKTtcbn1cblxuLy8gc3JjL3V0aWxzL19zdHJpbmdpZnkvX3N0cmluZ2lmeS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9zdHJpbmdpZnkoaW5wdXQpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYFwiJHtpbnB1dH1cImA7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBgJHtpbnB1dH1gO1xuICB9XG4gIGlmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAoaW5wdXQgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGlucHV0KT8uY29uc3RydWN0b3I/Lm5hbWUpID8/IFwibnVsbFwiO1xuICB9XG4gIHJldHVybiB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvX2FkZElzc3VlL19hZGRJc3N1ZS50c1xuZnVuY3Rpb24gX2FkZElzc3VlKGNvbnRleHQsIGxhYmVsLCBkYXRhc2V0LCBjb25maWcyLCBvdGhlcikge1xuICBjb25zdCBpbnB1dCA9IG90aGVyICYmIFwiaW5wdXRcIiBpbiBvdGhlciA/IG90aGVyLmlucHV0IDogZGF0YXNldC52YWx1ZTtcbiAgY29uc3QgZXhwZWN0ZWQgPSBvdGhlcj8uZXhwZWN0ZWQgPz8gY29udGV4dC5leHBlY3RzID8/IG51bGw7XG4gIGNvbnN0IHJlY2VpdmVkID0gb3RoZXI/LnJlY2VpdmVkID8/IF9zdHJpbmdpZnkoaW5wdXQpO1xuICBjb25zdCBpc3N1ZSA9IHtcbiAgICBraW5kOiBjb250ZXh0LmtpbmQsXG4gICAgdHlwZTogY29udGV4dC50eXBlLFxuICAgIGlucHV0LFxuICAgIGV4cGVjdGVkLFxuICAgIHJlY2VpdmVkLFxuICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bGFiZWx9OiAke2V4cGVjdGVkID8gYEV4cGVjdGVkICR7ZXhwZWN0ZWR9IGJ1dCByYCA6IFwiUlwifWVjZWl2ZWQgJHtyZWNlaXZlZH1gLFxuICAgIHJlcXVpcmVtZW50OiBjb250ZXh0LnJlcXVpcmVtZW50LFxuICAgIHBhdGg6IG90aGVyPy5wYXRoLFxuICAgIGlzc3Vlczogb3RoZXI/Lmlzc3VlcyxcbiAgICBsYW5nOiBjb25maWcyLmxhbmcsXG4gICAgYWJvcnRFYXJseTogY29uZmlnMi5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBjb25maWcyLmFib3J0UGlwZUVhcmx5XG4gIH07XG4gIGNvbnN0IGlzU2NoZW1hID0gY29udGV4dC5raW5kID09PSBcInNjaGVtYVwiO1xuICBjb25zdCBtZXNzYWdlID0gb3RoZXI/Lm1lc3NhZ2UgPz8gY29udGV4dC5tZXNzYWdlID8/IGdldFNwZWNpZmljTWVzc2FnZShjb250ZXh0LnJlZmVyZW5jZSwgaXNzdWUubGFuZykgPz8gKGlzU2NoZW1hID8gZ2V0U2NoZW1hTWVzc2FnZShpc3N1ZS5sYW5nKSA6IG51bGwpID8/IGNvbmZpZzIubWVzc2FnZSA/PyBnZXRHbG9iYWxNZXNzYWdlKGlzc3VlLmxhbmcpO1xuICBpZiAobWVzc2FnZSAhPT0gdm9pZCAwKSB7XG4gICAgaXNzdWUubWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgPyAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICBtZXNzYWdlKGlzc3VlKVxuICAgICkgOiBtZXNzYWdlO1xuICB9XG4gIGlmIChpc1NjaGVtYSkge1xuICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICBkYXRhc2V0Lmlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhc2V0Lmlzc3VlcyA9IFtpc3N1ZV07XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzL19nZXRCeXRlQ291bnQvX2dldEJ5dGVDb3VudC50c1xudmFyIHRleHRFbmNvZGVyO1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9nZXRCeXRlQ291bnQoaW5wdXQpIHtcbiAgaWYgKCF0ZXh0RW5jb2Rlcikge1xuICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIH1cbiAgcmV0dXJuIHRleHRFbmNvZGVyLmVuY29kZShpbnB1dCkubGVuZ3RoO1xufVxuXG4vLyBzcmMvdXRpbHMvX2dldEdyYXBoZW1lQ291bnQvX2dldEdyYXBoZW1lQ291bnQudHNcbnZhciBzZWdtZW50ZXI7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2dldEdyYXBoZW1lQ291bnQoaW5wdXQpIHtcbiAgaWYgKCFzZWdtZW50ZXIpIHtcbiAgICBzZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIoKTtcbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHNlZ21lbnRlci5zZWdtZW50KGlucHV0KTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBfIG9mIHNlZ21lbnRzKSB7XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbi8vIHNyYy91dGlscy9fZ2V0U3RhbmRhcmRQcm9wcy9fZ2V0U3RhbmRhcmRQcm9wcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9nZXRTdGFuZGFyZFByb3BzKGNvbnRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHZlbmRvcjogXCJ2YWxpYm90XCIsXG4gICAgdmFsaWRhdGUodmFsdWUyKSB7XG4gICAgICByZXR1cm4gY29udGV4dFtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGdldEdsb2JhbENvbmZpZygpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy9fZ2V0V29yZENvdW50L19nZXRXb3JkQ291bnQudHNcbnZhciBzdG9yZTU7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2dldFdvcmRDb3VudChsb2NhbGVzLCBpbnB1dCkge1xuICBpZiAoIXN0b3JlNSkge1xuICAgIHN0b3JlNSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgaWYgKCFzdG9yZTUuZ2V0KGxvY2FsZXMpKSB7XG4gICAgc3RvcmU1LnNldChsb2NhbGVzLCBuZXcgSW50bC5TZWdtZW50ZXIobG9jYWxlcywgeyBncmFudWxhcml0eTogXCJ3b3JkXCIgfSkpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc3RvcmU1LmdldChsb2NhbGVzKS5zZWdtZW50KGlucHV0KTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnQuaXNXb3JkTGlrZSkge1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vLyBzcmMvdXRpbHMvX2lzTHVobkFsZ28vX2lzTHVobkFsZ28udHNcbnZhciBOT05fRElHSVRfUkVHRVggPSAvXFxEL2d1O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9pc0x1aG5BbGdvKGlucHV0KSB7XG4gIGNvbnN0IG51bWJlcjIgPSBpbnB1dC5yZXBsYWNlKE5PTl9ESUdJVF9SRUdFWCwgXCJcIik7XG4gIGxldCBsZW5ndGgyID0gbnVtYmVyMi5sZW5ndGg7XG4gIGxldCBiaXQgPSAxO1xuICBsZXQgc3VtID0gMDtcbiAgd2hpbGUgKGxlbmd0aDIpIHtcbiAgICBjb25zdCB2YWx1ZTIgPSArbnVtYmVyMlstLWxlbmd0aDJdO1xuICAgIGJpdCBePSAxO1xuICAgIHN1bSArPSBiaXQgPyBbMCwgMiwgNCwgNiwgOCwgMSwgMywgNSwgNywgOV1bdmFsdWUyXSA6IHZhbHVlMjtcbiAgfVxuICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG59XG5cbi8vIHNyYy91dGlscy9faXNWYWxpZE9iamVjdEtleS9faXNWYWxpZE9iamVjdEtleS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9pc1ZhbGlkT2JqZWN0S2V5KG9iamVjdDIsIGtleSkge1xuICByZXR1cm4gT2JqZWN0Lmhhc093bihvYmplY3QyLCBrZXkpICYmIGtleSAhPT0gXCJfX3Byb3RvX19cIiAmJiBrZXkgIT09IFwicHJvdG90eXBlXCIgJiYga2V5ICE9PSBcImNvbnN0cnVjdG9yXCI7XG59XG5cbi8vIHNyYy91dGlscy9fam9pbkV4cGVjdHMvX2pvaW5FeHBlY3RzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gX2pvaW5FeHBlY3RzKHZhbHVlczIsIHNlcGFyYXRvcikge1xuICBjb25zdCBsaXN0ID0gWy4uLm5ldyBTZXQodmFsdWVzMildO1xuICBpZiAobGlzdC5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGAoJHtsaXN0LmpvaW4oYCAke3NlcGFyYXRvcn0gYCl9KWA7XG4gIH1cbiAgcmV0dXJuIGxpc3RbMF0gPz8gXCJuZXZlclwiO1xufVxuXG4vLyBzcmMvdXRpbHMvZW50cmllc0Zyb21MaXN0L2VudHJpZXNGcm9tTGlzdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGVudHJpZXNGcm9tTGlzdChsaXN0LCBzY2hlbWEpIHtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBsaXN0KSB7XG4gICAgZW50cmllc1trZXldID0gc2NoZW1hO1xuICB9XG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG4vLyBzcmMvdXRpbHMvZW50cmllc0Zyb21PYmplY3RzL2VudHJpZXNGcm9tT2JqZWN0cy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGVudHJpZXNGcm9tT2JqZWN0cyhzY2hlbWFzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgIE9iamVjdC5hc3NpZ24oZW50cmllcywgc2NoZW1hLmVudHJpZXMpO1xuICB9XG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG4vLyBzcmMvdXRpbHMvZ2V0RG90UGF0aC9nZXREb3RQYXRoLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0RG90UGF0aChpc3N1ZSkge1xuICBpZiAoaXNzdWUucGF0aCkge1xuICAgIGxldCBrZXkgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpc3N1ZS5wYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0ua2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpdGVtLmtleSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAga2V5ICs9IGAuJHtpdGVtLmtleX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSArPSBpdGVtLmtleTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIHNyYy91dGlscy9pc09mS2luZC9pc09mS2luZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlzT2ZLaW5kKGtpbmQsIG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIua2luZCA9PT0ga2luZDtcbn1cblxuLy8gc3JjL3V0aWxzL2lzT2ZUeXBlL2lzT2ZUeXBlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNPZlR5cGUodHlwZSwgb2JqZWN0Mikge1xuICByZXR1cm4gb2JqZWN0Mi50eXBlID09PSB0eXBlO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNWYWxpRXJyb3IvaXNWYWxpRXJyb3IudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpc1ZhbGlFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBWYWxpRXJyb3I7XG59XG5cbi8vIHNyYy91dGlscy9WYWxpRXJyb3IvVmFsaUVycm9yLnRzXG52YXIgVmFsaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgVmFsaWJvdCBlcnJvciB3aXRoIHVzZWZ1bCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlzc3VlcyBUaGUgZXJyb3IgaXNzdWVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoaXNzdWVzWzBdLm1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiVmFsaUVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbn07XG5cbi8vIHNyYy9hY3Rpb25zL2FyZ3MvYXJncy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGFyZ3Moc2NoZW1hKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiYXJnc1wiLFxuICAgIHJlZmVyZW5jZTogYXJncyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgc2NoZW1hLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGZ1bmMgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgZGF0YXNldC52YWx1ZSA9ICguLi5hcmdzXykgPT4ge1xuICAgICAgICBjb25zdCBhcmdzRGF0YXNldCA9IHRoaXMuc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBhcmdzXyB9LCBjb25maWcyKTtcbiAgICAgICAgaWYgKGFyZ3NEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgIHRocm93IG5ldyBWYWxpRXJyb3IoYXJnc0RhdGFzZXQuaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyguLi5hcmdzRGF0YXNldC52YWx1ZSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9hcmdzL2FyZ3NBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGFyZ3NBc3luYyhzY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJhcmdzXCIsXG4gICAgcmVmZXJlbmNlOiBhcmdzQXN5bmMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHNjaGVtYSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBmdW5jID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBhc3luYyAoLi4uYXJnczIpID0+IHtcbiAgICAgICAgY29uc3QgYXJnc0RhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGFyZ3MyIH0sIGNvbmZpZzIpO1xuICAgICAgICBpZiAoYXJnc0RhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbGlFcnJvcihhcmdzRGF0YXNldC5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3NEYXRhc2V0LnZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2F3YWl0L2F3YWl0QXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBhd2FpdEFzeW5jKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImF3YWl0XCIsXG4gICAgcmVmZXJlbmNlOiBhd2FpdEFzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBhd2FpdCBkYXRhc2V0LnZhbHVlO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvcmVnZXgudHNcbnZhciBCQVNFNjRfUkVHRVggPSAvXig/OltcXGRhLXorL117NH0pKig/OltcXGRhLXorL117Mn09PXxbXFxkYS16Ky9dezN9PSk/JC9pdTtcbnZhciBCSUNfUkVHRVggPSAvXltBLVpdezZ9KD8hMDApW1xcZEEtWl17Mn0oPzpbXFxkQS1aXXszfSk/JC91O1xudmFyIENVSUQyX1JFR0VYID0gL15bYS16XVtcXGRhLXpdKiQvdTtcbnZhciBERUNJTUFMX1JFR0VYID0gL15bKy1dPyg/OlxcZCpcXC4pP1xcZCskL3U7XG52YXIgRElHSVRTX1JFR0VYID0gL15cXGQrJC91O1xudmFyIEVNQUlMX1JFR0VYID0gL15bXFx3Ky1dKyg/OlxcLltcXHcrLV0rKSpAW1xcZGEtel0rKD86Wy4tXVtcXGRhLXpdKykqXFwuW2Etel17Mix9JC9pdTtcbnZhciBFTU9KSV9SRUdFWCA9IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zLWRldGVjdG9yL25vLXVuc2FmZS1yZWdleCwgcmVnZXhwL25vLWR1cGUtZGlzanVuY3Rpb25zIC0tIGZhbHNlIHBvc2l0aXZlc1xuICAvXig/OltcXHV7MUYxRTZ9LVxcdXsxRjFGRn1dezJ9fFxcdXsxRjNGNH1bXFx1e0UwMDYxfS1cXHV7RTAwN0F9XXsyfVtcXHV7RTAwMzB9LVxcdXtFMDAzOX1cXHV7RTAwNjF9LVxcdXtFMDA3QX1dezEsM31cXHV7RTAwN0Z9fCg/OlxccHtFbW9qaX1cXHVGRTBGXFx1MjBFMz98XFxwe0Vtb2ppX01vZGlmaWVyX0Jhc2V9XFxwe0Vtb2ppX01vZGlmaWVyfT98XFxwe0Vtb2ppX1ByZXNlbnRhdGlvbn0pKD86XFx1MjAwRCg/OlxccHtFbW9qaX1cXHVGRTBGXFx1MjBFMz98XFxwe0Vtb2ppX01vZGlmaWVyX0Jhc2V9XFxwe0Vtb2ppX01vZGlmaWVyfT98XFxwe0Vtb2ppX1ByZXNlbnRhdGlvbn0pKSopKyQvdVxuKTtcbnZhciBIRVhBREVDSU1BTF9SRUdFWCA9IC9eKD86MFtoeF0pP1tcXGRhLWZBLUZdKyQvdTtcbnZhciBIRVhfQ09MT1JfUkVHRVggPSAvXiMoPzpbXFxkYS1mQS1GXXszLDR9fFtcXGRhLWZBLUZdezZ9fFtcXGRhLWZBLUZdezh9KSQvdTtcbnZhciBJTUVJX1JFR0VYID0gL15cXGR7MTV9JHxeXFxkezJ9LVxcZHs2fS1cXGR7Nn0tXFxkJC91O1xudmFyIElQVjRfUkVHRVggPSAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXggLS0gZmFsc2UgcG9zaXRpdmVcbiAgL14oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKD86XFwuKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSl7M30kL3Vcbik7XG52YXIgSVBWNl9SRUdFWCA9IC9eKD86KD86W1xcZGEtZl17MSw0fTopezd9W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw3fTp8KD86W1xcZGEtZl17MSw0fTopezEsNn06W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw1fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDJ9fCg/OltcXGRhLWZdezEsNH06KXsxLDR9KD86OltcXGRhLWZdezEsNH0pezEsM318KD86W1xcZGEtZl17MSw0fTopezEsM30oPzo6W1xcZGEtZl17MSw0fSl7MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwyfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDV9fFtcXGRhLWZdezEsNH06KD86OltcXGRhLWZdezEsNH0pezEsNn18Oig/Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDd9fDopfGZlODA6KD86OltcXGRhLWZdezAsNH0pezAsNH0lW1xcZGEtel0rfDo6KD86Zns0fSg/OjowezEsNH0pPzopPyg/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpfCg/OltcXGRhLWZdezEsNH06KXsxLDR9Oig/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpKSQvaXU7XG52YXIgSVBfUkVHRVggPSAvXig/Oig/OlsxLTldfDFcXGR8MlswLTRdKT9cXGR8MjVbMC01XSkoPzpcXC4oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKXszfSR8Xig/Oig/OltcXGRhLWZdezEsNH06KXs3fVtcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsN306fCg/OltcXGRhLWZdezEsNH06KXsxLDZ9OltcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsNX0oPzo6W1xcZGEtZl17MSw0fSl7MSwyfXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDN9fCg/OltcXGRhLWZdezEsNH06KXsxLDN9KD86OltcXGRhLWZdezEsNH0pezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsMn0oPzo6W1xcZGEtZl17MSw0fSl7MSw1fXxbXFxkYS1mXXsxLDR9Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDZ9fDooPzooPzo6W1xcZGEtZl17MSw0fSl7MSw3fXw6KXxmZTgwOig/OjpbXFxkYS1mXXswLDR9KXswLDR9JVtcXGRhLXpdK3w6Oig/OmZ7NH0oPzo6MHsxLDR9KT86KT8oPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fTooPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKSkkL2l1O1xudmFyIElTT19EQVRFX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pJC91O1xudmFyIElTT19EQVRFX1RJTUVfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSlbVCBdKD86MFxcZHwxXFxkfDJbMC0zXSk6WzAtNV1cXGQkL3U7XG52YXIgSVNPX1RJTUVfUkVHRVggPSAvXig/OjBcXGR8MVxcZHwyWzAtM10pOlswLTVdXFxkJC91O1xudmFyIElTT19USU1FX1NFQ09ORF9SRUdFWCA9IC9eKD86MFxcZHwxXFxkfDJbMC0zXSkoPzo6WzAtNV1cXGQpezJ9JC91O1xudmFyIElTT19USU1FU1RBTVBfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSlbVCBdKD86MFxcZHwxXFxkfDJbMC0zXSkoPzo6WzAtNV1cXGQpezJ9KD86XFwuXFxkezEsOX0pPyg/Olp8WystXSg/OjBcXGR8MVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KSQvdTtcbnZhciBJU09fV0VFS19SRUdFWCA9IC9eXFxkezR9LVcoPzowWzEtOV18WzEtNF1cXGR8NVswLTNdKSQvdTtcbnZhciBNQUM0OF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezJ9W1xcZGEtZl17NH0kL2l1O1xudmFyIE1BQzY0X1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7M31bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezR9Oil7M31bXFxkYS1mXXs0fSQvaXU7XG52YXIgTUFDX1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezV9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezV9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7Mn1bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezJ9Oil7N31bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezJ9LSl7N31bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezR9XFwuKXszfVtcXGRhLWZdezR9JHxeKD86W1xcZGEtZl17NH06KXszfVtcXGRhLWZdezR9JC9pdTtcbnZhciBOQU5PX0lEX1JFR0VYID0gL15bXFx3LV0rJC91O1xudmFyIE9DVEFMX1JFR0VYID0gL14oPzowbyk/WzAtN10rJC91O1xudmFyIFJGQ19FTUFJTF9SRUdFWCA9IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9wcmVmZXItdywgbm8tdXNlbGVzcy1lc2NhcGUsIHJlZ2V4cC9uby11c2VsZXNzLWVzY2FwZSwgcmVnZXhwL3JlcXVpcmUtdW5pY29kZS1yZWdleHBcbiAgL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC9cbik7XG52YXIgU0xVR19SRUdFWCA9IC9eW1xcZGEtel0rKD86Wy1fXVtcXGRhLXpdKykqJC91O1xudmFyIFVMSURfUkVHRVggPSAvXltcXGRhLWhqa21ucC10di16QS1ISktNTlAtVFYtWl17MjZ9JC91O1xudmFyIFVVSURfUkVHRVggPSAvXltcXGRhLWZdezh9KD86LVtcXGRhLWZdezR9KXszfS1bXFxkYS1mXXsxMn0kL2l1O1xuXG4vLyBzcmMvYWN0aW9ucy9iYXNlNjQvYmFzZTY0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYmFzZTY0KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImJhc2U2NFwiLFxuICAgIHJlZmVyZW5jZTogYmFzZTY0LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBCQVNFNjRfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkJhc2U2NFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvYmljL2JpYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJpYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJiaWNcIixcbiAgICByZWZlcmVuY2U6IGJpYyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogQklDX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJCSUNcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2JyYW5kL2JyYW5kLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYnJhbmQobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImJyYW5kXCIsXG4gICAgcmVmZXJlbmNlOiBicmFuZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbmFtZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2J5dGVzL2J5dGVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgcmVmZXJlbmNlOiBieXRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBfZ2V0Qnl0ZUNvdW50KGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAobGVuZ3RoMiAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jaGVjay9jaGVjay50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNoZWNrKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjaGVja1wiLFxuICAgIHJlZmVyZW5jZTogY2hlY2ssXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvY2hlY2svY2hlY2tBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNoZWNrQXN5bmMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImNoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBjaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhYXdhaXQgdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvY2hlY2tJdGVtcy9jaGVja0l0ZW1zLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY2hlY2tJdGVtcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiY2hlY2tfaXRlbXNcIixcbiAgICByZWZlcmVuY2U6IGNoZWNrSXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGF0YXNldC52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YXNldC52YWx1ZVtpbmRleF07XG4gICAgICAgICAgaWYgKCF0aGlzLnJlcXVpcmVtZW50KGl0ZW0sIGluZGV4LCBkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiBpdGVtLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogZGF0YXNldC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2NoZWNrSXRlbXMvY2hlY2tJdGVtc0FzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY2hlY2tJdGVtc0FzeW5jKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjaGVja19pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogY2hlY2tJdGVtc0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCByZXF1aXJlbWVudFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLm1hcCh0aGlzLnJlcXVpcmVtZW50KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGF0YXNldC52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAoIXJlcXVpcmVtZW50UmVzdWx0c1tpbmRleF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhc2V0LnZhbHVlW2luZGV4XTtcbiAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIml0ZW1cIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogaXRlbSxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGRhdGFzZXQudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jcmVkaXRDYXJkL2NyZWRpdENhcmQudHNcbnZhciBDUkVESVRfQ0FSRF9SRUdFWCA9IC9eKD86XFxkezE0LDE5fXxcXGR7NH0oPzogXFxkezMsNn0pezIsNH18XFxkezR9KD86LVxcZHszLDZ9KXsyLDR9KSQvdTtcbnZhciBTQU5JVElaRV9SRUdFWCA9IC9bLSBdL2d1O1xudmFyIFBST1ZJREVSX1JFR0VYX0xJU1QgPSBbXG4gIC8vIEFtZXJpY2FuIEV4cHJlc3NcbiAgL14zWzQ3XVxcZHsxM30kL3UsXG4gIC8vIERpbmVycyBDbHViXG4gIC9eMyg/OjBbMC01XXxbNjhdXFxkKVxcZHsxMSwxM30kL3UsXG4gIC8vIERpc2NvdmVyXG4gIC9eNig/OjAxMXw1XFxkezJ9KVxcZHsxMiwxNX0kL3UsXG4gIC8vIEpDQlxuICAvXig/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9JC91LFxuICAvLyBNYXN0ZXJjYXJkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXhcbiAgL141WzEtNV1cXGR7Mn18KD86MjIyXFxkfDIyWzMtOV1cXGR8MlszLTZdXFxkezJ9fDI3WzAxXVxcZHwyNzIwKVxcZHsxMn0kL3UsXG4gIC8vIFVuaW9uUGF5XG4gIC9eKD86NlsyN11cXGR7MTQsMTd9fDgxXFxkezE0LDE3fSkkL3UsXG4gIC8vIFZpc2FcbiAgL140XFxkezEyfSg/OlxcZHszLDZ9KT8kL3Vcbl07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gY3JlZGl0Q2FyZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJjcmVkaXRfY2FyZFwiLFxuICAgIHJlZmVyZW5jZTogY3JlZGl0Q2FyZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudChpbnB1dCkge1xuICAgICAgbGV0IHNhbml0aXplZDtcbiAgICAgIHJldHVybiBDUkVESVRfQ0FSRF9SRUdFWC50ZXN0KGlucHV0KSAmJiAvLyBSZW1vdmUgYW55IGh5cGhlbnMgYW5kIGJsYW5rc1xuICAgICAgKHNhbml0aXplZCA9IGlucHV0LnJlcGxhY2UoU0FOSVRJWkVfUkVHRVgsIFwiXCIpKSAmJiAvLyBDaGVjayBpZiBpdCBtYXRjaGVzIGEgcHJvdmlkZXJcbiAgICAgIFBST1ZJREVSX1JFR0VYX0xJU1Quc29tZSgocmVnZXgyKSA9PiByZWdleDIudGVzdChzYW5pdGl6ZWQpKSAmJiAvLyBDaGVjayBpZiBwYXNzZXMgbHVobiBhbGdvcml0aG1cbiAgICAgIF9pc0x1aG5BbGdvKHNhbml0aXplZCk7XG4gICAgfSxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImNyZWRpdCBjYXJkXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jdWlkMi9jdWlkMi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGN1aWQyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImN1aWQyXCIsXG4gICAgcmVmZXJlbmNlOiBjdWlkMixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogQ1VJRDJfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIkN1aWQyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9kZWNpbWFsL2RlY2ltYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBkZWNpbWFsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImRlY2ltYWxcIixcbiAgICByZWZlcmVuY2U6IGRlY2ltYWwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IERFQ0lNQUxfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImRlY2ltYWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2Rlc2NyaXB0aW9uL2Rlc2NyaXB0aW9uLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGVzY3JpcHRpb24oZGVzY3JpcHRpb25fKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJtZXRhZGF0YVwiLFxuICAgIHR5cGU6IFwiZGVzY3JpcHRpb25cIixcbiAgICByZWZlcmVuY2U6IGRlc2NyaXB0aW9uLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbl9cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZGlnaXRzL2RpZ2l0cy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGRpZ2l0cyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJkaWdpdHNcIixcbiAgICByZWZlcmVuY2U6IGRpZ2l0cyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogRElHSVRTX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJkaWdpdHNcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2VtYWlsL2VtYWlsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZW1haWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZW1haWxcIixcbiAgICByZWZlcmVuY2U6IGVtYWlsLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50OiBFTUFJTF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW1haWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2Vtb2ppL2Vtb2ppLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZW1vamkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZW1vamlcIixcbiAgICByZWZlcmVuY2U6IGVtb2ppLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBFTU9KSV9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZW1vamlcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2VtcHR5L2VtcHR5LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZW1wdHkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZW1wdHlcIixcbiAgICByZWZlcmVuY2U6IGVtcHR5LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBcIjBcIixcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9lbmRzV2l0aC9lbmRzV2l0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGVuZHNXaXRoKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJlbmRzX3dpdGhcIixcbiAgICByZWZlcmVuY2U6IGVuZHNXaXRoLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgXCIke3JlcXVpcmVtZW50fVwiYCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFkYXRhc2V0LnZhbHVlLmVuZHNXaXRoKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImVuZFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGBcIiR7ZGF0YXNldC52YWx1ZS5zbGljZSgtdGhpcy5yZXF1aXJlbWVudC5sZW5ndGgpfVwiYFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZXZlcnlJdGVtL2V2ZXJ5SXRlbS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGV2ZXJ5SXRlbShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZXZlcnlfaXRlbVwiLFxuICAgIHJlZmVyZW5jZTogZXZlcnlJdGVtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuZXZlcnkodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZXhjbHVkZXMvZXhjbHVkZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBleGNsdWRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICBjb25zdCByZWNlaXZlZCA9IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZXhjbHVkZXNcIixcbiAgICByZWZlcmVuY2U6IGV4Y2x1ZGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVjZWl2ZWR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiY29udGVudFwiLCBkYXRhc2V0LCBjb25maWcyLCB7IHJlY2VpdmVkIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9maWx0ZXJJdGVtcy9maWx0ZXJJdGVtcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZpbHRlckl0ZW1zKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImZpbHRlcl9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogZmlsdGVySXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5maWx0ZXIodGhpcy5vcGVyYXRpb24pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9maW5kSXRlbS9maW5kSXRlbS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZpbmRJdGVtKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImZpbmRfaXRlbVwiLFxuICAgIHJlZmVyZW5jZTogZmluZEl0ZW0sXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5maW5kKHRoaXMub3BlcmF0aW9uKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZmluaXRlL2Zpbml0ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZpbml0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJmaW5pdGVcIixcbiAgICByZWZlcmVuY2U6IGZpbml0ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTnVtYmVyLmlzRmluaXRlLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZmluaXRlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ncmFwaGVtZXMvZ3JhcGhlbWVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ3JhcGhlbWVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJncmFwaGVtZXNcIixcbiAgICByZWZlcmVuY2U6IGdyYXBoZW1lcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gX2dldEdyYXBoZW1lQ291bnQoZGF0YXNldC52YWx1ZSk7XG4gICAgICAgIGlmIChjb3VudCAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImdyYXBoZW1lc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7Y291bnR9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2d0VmFsdWUvZ3RWYWx1ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGd0VmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImd0X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiBndFZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPiR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIShkYXRhc2V0LnZhbHVlID4gdGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9oYXNoL2hhc2gudHNcbnZhciBIQVNIX0xFTkdUSFMgPSB7XG4gIG1kNDogMzIsXG4gIG1kNTogMzIsXG4gIHNoYTE6IDQwLFxuICBzaGEyNTY6IDY0LFxuICBzaGEzODQ6IDk2LFxuICBzaGE1MTI6IDEyOCxcbiAgcmlwZW1kMTI4OiAzMixcbiAgcmlwZW1kMTYwOiA0MCxcbiAgdGlnZXIxMjg6IDMyLFxuICB0aWdlcjE2MDogNDAsXG4gIHRpZ2VyMTkyOiA0OCxcbiAgY3JjMzI6IDgsXG4gIGNyYzMyYjogOCxcbiAgYWRsZXIzMjogOFxufTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBoYXNoKHR5cGVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJoYXNoXCIsXG4gICAgcmVmZXJlbmNlOiBoYXNoLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50OiBSZWdFeHAoXG4gICAgICB0eXBlcy5tYXAoKHR5cGUpID0+IGBeW2EtZjAtOV17JHtIQVNIX0xFTkdUSFNbdHlwZV19fSRgKS5qb2luKFwifFwiKSxcbiAgICAgIFwiaXVcIlxuICAgICksXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImhhc2hcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2hleGFkZWNpbWFsL2hleGFkZWNpbWFsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaGV4YWRlY2ltYWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaGV4YWRlY2ltYWxcIixcbiAgICByZWZlcmVuY2U6IGhleGFkZWNpbWFsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBIRVhBREVDSU1BTF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaGV4YWRlY2ltYWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2hleENvbG9yL2hleENvbG9yLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaGV4Q29sb3IobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaGV4X2NvbG9yXCIsXG4gICAgcmVmZXJlbmNlOiBoZXhDb2xvcixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSEVYX0NPTE9SX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJoZXggY29sb3JcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ltZWkvaW1laS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGltZWkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaW1laVwiLFxuICAgIHJlZmVyZW5jZTogaW1laSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudChpbnB1dCkge1xuICAgICAgcmV0dXJuIElNRUlfUkVHRVgudGVzdChpbnB1dCkgJiYgX2lzTHVobkFsZ28oaW5wdXQpO1xuICAgIH0sXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJJTUVJXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pbmNsdWRlcy9pbmNsdWRlcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGluY2x1ZGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIGNvbnN0IGV4cGVjdHMgPSBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImluY2x1ZGVzXCIsXG4gICAgcmVmZXJlbmNlOiBpbmNsdWRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0cyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFkYXRhc2V0LnZhbHVlLmluY2x1ZGVzKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImNvbnRlbnRcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgISR7ZXhwZWN0c31gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pbnRlZ2VyL2ludGVnZXIudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpbnRlZ2VyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICByZWZlcmVuY2U6IGludGVnZXIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc0ludGVnZXIsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpbnRlZ2VyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pcC9pcC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlwKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlwXCIsXG4gICAgcmVmZXJlbmNlOiBpcCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVBfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklQXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pcHY0L2lwdjQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpcHY0KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlwdjRcIixcbiAgICByZWZlcmVuY2U6IGlwdjQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElQVjRfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIklQdjRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lwdjYvaXB2Ni50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlwdjYobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXB2NlwiLFxuICAgIHJlZmVyZW5jZTogaXB2NixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVBWNl9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiSVB2NlwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXNvRGF0ZS9pc29EYXRlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNvRGF0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fZGF0ZVwiLFxuICAgIHJlZmVyZW5jZTogaXNvRGF0ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX0RBVEVfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImRhdGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb0RhdGVUaW1lL2lzb0RhdGVUaW1lLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXNvX2RhdGVfdGltZVwiLFxuICAgIHJlZmVyZW5jZTogaXNvRGF0ZVRpbWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19EQVRFX1RJTUVfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImRhdGUtdGltZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXNvVGltZS9pc29UaW1lLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNvVGltZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fdGltZVwiLFxuICAgIHJlZmVyZW5jZTogaXNvVGltZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX1RJTUVfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInRpbWVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb1RpbWVTZWNvbmQvaXNvVGltZVNlY29uZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGlzb1RpbWVTZWNvbmQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXNvX3RpbWVfc2Vjb25kXCIsXG4gICAgcmVmZXJlbmNlOiBpc29UaW1lU2Vjb25kLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fVElNRV9TRUNPTkRfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInRpbWUtc2Vjb25kXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29UaW1lc3RhbXAvaXNvVGltZXN0YW1wLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaXNvVGltZXN0YW1wKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb190aW1lc3RhbXBcIixcbiAgICByZWZlcmVuY2U6IGlzb1RpbWVzdGFtcCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX1RJTUVTVEFNUF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidGltZXN0YW1wXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29XZWVrL2lzb1dlZWsudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpc29XZWVrKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb193ZWVrXCIsXG4gICAgcmVmZXJlbmNlOiBpc29XZWVrLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fV0VFS19SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwid2Vla1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbGVuZ3RoL2xlbmd0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibGVuZ3RoXCIsXG4gICAgcmVmZXJlbmNlOiBsZW5ndGgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9sdFZhbHVlL2x0VmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBsdFZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJsdF92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogbHRWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDwke3JlcXVpcmVtZW50IGluc3RhbmNlb2YgRGF0ZSA/IHJlcXVpcmVtZW50LnRvSlNPTigpIDogX3N0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEoZGF0YXNldC52YWx1ZSA8IHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFjL21hYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1hYyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYWNcIixcbiAgICByZWZlcmVuY2U6IG1hYyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogTUFDX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJNQUNcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21hYzQ4L21hYzQ4LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFjNDgobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWFjNDhcIixcbiAgICByZWZlcmVuY2U6IG1hYzQ4LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBNQUM0OF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiNDgtYml0IE1BQ1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFjNjQvbWFjNjQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYWM2NChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYWM2NFwiLFxuICAgIHJlZmVyZW5jZTogbWFjNjQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE1BQzY0X1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCI2NC1iaXQgTUFDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXBJdGVtcy9tYXBJdGVtcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1hcEl0ZW1zKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcIm1hcF9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogbWFwSXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5tYXAodGhpcy5vcGVyYXRpb24pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXhCeXRlcy9tYXhCeXRlcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1heEJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IG1heEJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gX2dldEJ5dGVDb3VudChkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGxlbmd0aDIgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiYnl0ZXNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2xlbmd0aDJ9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heEdyYXBoZW1lcy9tYXhHcmFwaGVtZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhHcmFwaGVtZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF9ncmFwaGVtZXNcIixcbiAgICByZWZlcmVuY2U6IG1heEdyYXBoZW1lcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBfZ2V0R3JhcGhlbWVDb3VudChkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImdyYXBoZW1lc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7Y291bnR9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heExlbmd0aC9tYXhMZW5ndGgudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG1heExlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5sZW5ndGggPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImxlbmd0aFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUubGVuZ3RofWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heFNpemUvbWF4U2l6ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1heFNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1heF9zaXplXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhTaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInNpemVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLnNpemV9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWF4VmFsdWUvbWF4VmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXhWYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhKGRhdGFzZXQudmFsdWUgPD0gdGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXhXb3Jkcy9tYXhXb3Jkcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1heFdvcmRzKGxvY2FsZXMsIHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfd29yZHNcIixcbiAgICByZWZlcmVuY2U6IG1heFdvcmRzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgbG9jYWxlcyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gX2dldFdvcmRDb3VudCh0aGlzLmxvY2FsZXMsIGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAoY291bnQgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwid29yZHNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tZXRhZGF0YS9tZXRhZGF0YS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhXykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwibWV0YWRhdGFcIixcbiAgICB0eXBlOiBcIm1ldGFkYXRhXCIsXG4gICAgcmVmZXJlbmNlOiBtZXRhZGF0YSxcbiAgICBtZXRhZGF0YTogbWV0YWRhdGFfXG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbWVUeXBlL21pbWVUeXBlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWltZVR5cGUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbWVfdHlwZVwiLFxuICAgIHJlZmVyZW5jZTogbWltZVR5cGUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhcbiAgICAgIHJlcXVpcmVtZW50Lm1hcCgob3B0aW9uKSA9PiBgXCIke29wdGlvbn1cImApLFxuICAgICAgXCJ8XCJcbiAgICApLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQuaW5jbHVkZXMoZGF0YXNldC52YWx1ZS50eXBlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJNSU1FIHR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgXCIke2RhdGFzZXQudmFsdWUudHlwZX1cImBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbkJ5dGVzL21pbkJ5dGVzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWluQnl0ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl9ieXRlc1wiLFxuICAgIHJlZmVyZW5jZTogbWluQnl0ZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBfZ2V0Qnl0ZUNvdW50KGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAobGVuZ3RoMiA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJieXRlc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7bGVuZ3RoMn1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluR3JhcGhlbWVzL21pbkdyYXBoZW1lcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1pbkdyYXBoZW1lcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX2dyYXBoZW1lc1wiLFxuICAgIHJlZmVyZW5jZTogbWluR3JhcGhlbWVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRHcmFwaGVtZUNvdW50KGRhdGFzZXQudmFsdWUpO1xuICAgICAgICBpZiAoY291bnQgPCB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZ3JhcGhlbWVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtjb3VudH1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluTGVuZ3RoL21pbkxlbmd0aC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1pbkxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX2xlbmd0aFwiLFxuICAgIHJlZmVyZW5jZTogbWluTGVuZ3RoLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWluU2l6ZS9taW5TaXplLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWluU2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX3NpemVcIixcbiAgICByZWZlcmVuY2U6IG1pblNpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuc2l6ZSA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5WYWx1ZS9taW5WYWx1ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG1pblZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW5fdmFsdWVcIixcbiAgICByZWZlcmVuY2U6IG1pblZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50IGluc3RhbmNlb2YgRGF0ZSA/IHJlcXVpcmVtZW50LnRvSlNPTigpIDogX3N0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEoZGF0YXNldC52YWx1ZSA+PSB0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbldvcmRzL21pbldvcmRzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWluV29yZHMobG9jYWxlcywgcmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl93b3Jkc1wiLFxuICAgIHJlZmVyZW5jZTogbWluV29yZHMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnR9YCxcbiAgICBsb2NhbGVzLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSBfZ2V0V29yZENvdW50KHRoaXMubG9jYWxlcywgZGF0YXNldC52YWx1ZSk7XG4gICAgICAgIGlmIChjb3VudCA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ3b3Jkc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7Y291bnR9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL211bHRpcGxlT2YvbXVsdGlwbGVPZi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG11bHRpcGxlT2YocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm11bHRpcGxlX29mXCIsXG4gICAgcmVmZXJlbmNlOiBtdWx0aXBsZU9mLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUgJSB0aGlzLnJlcXVpcmVtZW50ICE9PSAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIm11bHRpcGxlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9uYW5vaWQvbmFub2lkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbmFub2lkKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5hbm9pZFwiLFxuICAgIHJlZmVyZW5jZTogbmFub2lkLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBOQU5PX0lEX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJOYW5vIElEXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub25FbXB0eS9ub25FbXB0eS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vbkVtcHR5KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vbl9lbXB0eVwiLFxuICAgIHJlZmVyZW5jZTogbm9uRW1wdHksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IFwiITBcIixcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImxlbmd0aFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IFwiMFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3JtYWxpemUvbm9ybWFsaXplLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm9ybWFsaXplKGZvcm0pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJub3JtYWxpemVcIixcbiAgICByZWZlcmVuY2U6IG5vcm1hbGl6ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZm9ybSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5ub3JtYWxpemUodGhpcy5mb3JtKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90Qnl0ZXMvbm90Qnl0ZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub3RCeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X2J5dGVzXCIsXG4gICAgcmVmZXJlbmNlOiBub3RCeXRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gX2dldEJ5dGVDb3VudChkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGxlbmd0aDIgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJieXRlc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7bGVuZ3RoMn1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90R3JhcGhlbWVzL25vdEdyYXBoZW1lcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdEdyYXBoZW1lcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X2dyYXBoZW1lc1wiLFxuICAgIHJlZmVyZW5jZTogbm90R3JhcGhlbWVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gX2dldEdyYXBoZW1lQ291bnQoZGF0YXNldC52YWx1ZSk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImdyYXBoZW1lc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7Y291bnR9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdExlbmd0aC9ub3RMZW5ndGgudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub3RMZW5ndGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF9sZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IG5vdExlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLmxlbmd0aCA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3RTaXplL25vdFNpemUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub3RTaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJub3Rfc2l6ZVwiLFxuICAgIHJlZmVyZW5jZTogbm90U2l6ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlLnNpemUgPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9ub3RWYWx1ZS9ub3RWYWx1ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5vdFZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJub3RfdmFsdWVcIixcbiAgICByZWZlcmVuY2U6IG5vdFZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyBgISR7cmVxdWlyZW1lbnQudG9KU09OKCl9YCA6IGAhJHtfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgdGhpcy5yZXF1aXJlbWVudCA8PSBkYXRhc2V0LnZhbHVlICYmIHRoaXMucmVxdWlyZW1lbnQgPj0gZGF0YXNldC52YWx1ZSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdFZhbHVlcy9ub3RWYWx1ZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub3RWYWx1ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF92YWx1ZXNcIixcbiAgICByZWZlcmVuY2U6IG5vdFZhbHVlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke19qb2luRXhwZWN0cyhcbiAgICAgIHJlcXVpcmVtZW50Lm1hcChcbiAgICAgICAgKHZhbHVlMikgPT4gdmFsdWUyIGluc3RhbmNlb2YgRGF0ZSA/IHZhbHVlMi50b0pTT04oKSA6IF9zdHJpbmdpZnkodmFsdWUyKVxuICAgICAgKSxcbiAgICAgIFwifFwiXG4gICAgKX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgdGhpcy5yZXF1aXJlbWVudC5zb21lKFxuICAgICAgICAodmFsdWUyKSA9PiB2YWx1ZTIgPD0gZGF0YXNldC52YWx1ZSAmJiB2YWx1ZTIgPj0gZGF0YXNldC52YWx1ZVxuICAgICAgKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdFdvcmRzL25vdFdvcmRzLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm90V29yZHMobG9jYWxlcywgcmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vdF93b3Jkc1wiLFxuICAgIHJlZmVyZW5jZTogbm90V29yZHMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAhJHtyZXF1aXJlbWVudH1gLFxuICAgIGxvY2FsZXMsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRXb3JkQ291bnQodGhpcy5sb2NhbGVzLCBkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwid29yZHNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9vY3RhbC9vY3RhbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9jdGFsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm9jdGFsXCIsXG4gICAgcmVmZXJlbmNlOiBvY3RhbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogT0NUQUxfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIm9jdGFsXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9wYXJ0aWFsQ2hlY2svdXRpbHMvX2lzUGFydGlhbGx5VHlwZWQvX2lzUGFydGlhbGx5VHlwZWQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBfaXNQYXJ0aWFsbHlUeXBlZChkYXRhc2V0LCBwYXRocykge1xuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgbGV0IHR5cGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gTWF0aC5taW4ocGF0aC5sZW5ndGgsIGlzc3VlLnBhdGg/Lmxlbmd0aCA/PyAwKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGJvdW5kOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcGF0aFtpbmRleF0gIT09IGlzc3VlLnBhdGhbaW5kZXhdLmtleSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAocGF0aFtpbmRleF0gIT09IFwiJFwiIHx8IGlzc3VlLnBhdGhbaW5kZXhdLnR5cGUgIT09IFwiYXJyYXlcIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvYWN0aW9ucy9wYXJ0aWFsQ2hlY2svcGFydGlhbENoZWNrLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGFydGlhbENoZWNrKHBhdGhzLCByZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicGFydGlhbF9jaGVja1wiLFxuICAgIHJlZmVyZW5jZTogcGFydGlhbENoZWNrLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHBhdGhzLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKChkYXRhc2V0LnR5cGVkIHx8IF9pc1BhcnRpYWxseVR5cGVkKGRhdGFzZXQsIHBhdGhzKSkgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3BhcnRpYWxDaGVjay9wYXJ0aWFsQ2hlY2tBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHBhcnRpYWxDaGVja0FzeW5jKHBhdGhzLCByZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicGFydGlhbF9jaGVja1wiLFxuICAgIHJlZmVyZW5jZTogcGFydGlhbENoZWNrQXN5bmMsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBwYXRocyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICgoZGF0YXNldC50eXBlZCB8fCBfaXNQYXJ0aWFsbHlUeXBlZChkYXRhc2V0LCBwYXRocykpICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICFhd2FpdCB0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdDaGVjay9yYXdDaGVjay50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJhd0NoZWNrKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicmF3X2NoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiByYXdDaGVjayxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdDaGVjay9yYXdDaGVja0FzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcmF3Q2hlY2tBc3luYyhhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInJhd19jaGVja1wiLFxuICAgIHJlZmVyZW5jZTogcmF3Q2hlY2tBc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGF3YWl0IGFjdGlvbih7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGNvbmZpZzogY29uZmlnMixcbiAgICAgICAgYWRkSXNzdWU6IChpbmZvKSA9PiBfYWRkSXNzdWUodGhpcywgaW5mbz8ubGFiZWwgPz8gXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyLCBpbmZvKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3Jhd1RyYW5zZm9ybS9yYXdUcmFuc2Zvcm0udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByYXdUcmFuc2Zvcm0oYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmF3X3RyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogcmF3VHJhbnNmb3JtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbyksXG4gICAgICAgIE5FVkVSOiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdUcmFuc2Zvcm0vcmF3VHJhbnNmb3JtQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByYXdUcmFuc2Zvcm1Bc3luYyhhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJyYXdfdHJhbnNmb3JtXCIsXG4gICAgcmVmZXJlbmNlOiByYXdUcmFuc2Zvcm1Bc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbyksXG4gICAgICAgIE5FVkVSOiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZWFkb25seS9yZWFkb25seS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJlYWRvbmx5KCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJlYWRvbmx5XCIsXG4gICAgcmVmZXJlbmNlOiByZWFkb25seSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZWR1Y2VJdGVtcy9yZWR1Y2VJdGVtcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJlZHVjZUl0ZW1zKG9wZXJhdGlvbiwgaW5pdGlhbCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJlZHVjZV9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogcmVkdWNlSXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBpbml0aWFsLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnJlZHVjZSh0aGlzLm9wZXJhdGlvbiwgdGhpcy5pbml0aWFsKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmVnZXgvcmVnZXgudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZWdleChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicmVnZXhcIixcbiAgICByZWZlcmVuY2U6IHJlZ2V4LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJmb3JtYXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3JldHVybnMvcmV0dXJucy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJldHVybnMoc2NoZW1hKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmV0dXJuc1wiLFxuICAgIHJlZmVyZW5jZTogcmV0dXJucyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgc2NoZW1hLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGZ1bmMgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgZGF0YXNldC52YWx1ZSA9ICguLi5hcmdzXykgPT4ge1xuICAgICAgICBjb25zdCByZXR1cm5zRGF0YXNldCA9IHRoaXMuc2NoZW1hW1wifnJ1blwiXShcbiAgICAgICAgICB7IHZhbHVlOiBmdW5jKC4uLmFyZ3NfKSB9LFxuICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJldHVybnNEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgIHRocm93IG5ldyBWYWxpRXJyb3IocmV0dXJuc0RhdGFzZXQuaXNzdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuc0RhdGFzZXQudmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZXR1cm5zL3JldHVybnNBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJldHVybnNBc3luYyhzY2hlbWEpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJyZXR1cm5zXCIsXG4gICAgcmVmZXJlbmNlOiByZXR1cm5zQXN5bmMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHNjaGVtYSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBmdW5jID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBhc3luYyAoLi4uYXJnc18pID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuc0RhdGFzZXQgPSBhd2FpdCB0aGlzLnNjaGVtYVtcIn5ydW5cIl0oXG4gICAgICAgICAgeyB2YWx1ZTogYXdhaXQgZnVuYyguLi5hcmdzXykgfSxcbiAgICAgICAgICBjb25maWcyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZXR1cm5zRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsaUVycm9yKHJldHVybnNEYXRhc2V0Lmlzc3Vlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybnNEYXRhc2V0LnZhbHVlO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmZjRW1haWwvcmZjRW1haWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZmNFbWFpbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJyZmNfZW1haWxcIixcbiAgICByZWZlcmVuY2U6IHJmY0VtYWlsLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50OiBSRkNfRU1BSUxfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImVtYWlsXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zYWZlSW50ZWdlci9zYWZlSW50ZWdlci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNhZmVJbnRlZ2VyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInNhZmVfaW50ZWdlclwiLFxuICAgIHJlZmVyZW5jZTogc2FmZUludGVnZXIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc1NhZmVJbnRlZ2VyLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2FmZSBpbnRlZ2VyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zaXplL3NpemUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzaXplXCIsXG4gICAgcmVmZXJlbmNlOiBzaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5zaXplICE9PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInNpemVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLnNpemV9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvc2x1Zy9zbHVnLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc2x1ZyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzbHVnXCIsXG4gICAgcmVmZXJlbmNlOiBzbHVnLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBTTFVHX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzbHVnXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zb21lSXRlbS9zb21lSXRlbS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNvbWVJdGVtKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzb21lX2l0ZW1cIixcbiAgICByZWZlcmVuY2U6IHNvbWVJdGVtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuc29tZSh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpdGVtXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zb3J0SXRlbXMvc29ydEl0ZW1zLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc29ydEl0ZW1zKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInNvcnRfaXRlbXNcIixcbiAgICByZWZlcmVuY2U6IHNvcnRJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnNvcnQodGhpcy5vcGVyYXRpb24pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zdGFydHNXaXRoL3N0YXJ0c1dpdGgudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzdGFydHNXaXRoKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzdGFydHNfd2l0aFwiLFxuICAgIHJlZmVyZW5jZTogc3RhcnRzV2l0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYFwiJHtyZXF1aXJlbWVudH1cImAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhZGF0YXNldC52YWx1ZS5zdGFydHNXaXRoKHRoaXMucmVxdWlyZW1lbnQpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInN0YXJ0XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYFwiJHtkYXRhc2V0LnZhbHVlLnNsaWNlKDAsIHRoaXMucmVxdWlyZW1lbnQubGVuZ3RoKX1cImBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RpdGxlL3RpdGxlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdGl0bGUodGl0bGVfKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJtZXRhZGF0YVwiLFxuICAgIHR5cGU6IFwidGl0bGVcIixcbiAgICByZWZlcmVuY2U6IHRpdGxlLFxuICAgIHRpdGxlOiB0aXRsZV9cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdG9Mb3dlckNhc2UvdG9Mb3dlckNhc2UudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0b0xvd2VyQ2FzZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0b19sb3dlcl9jYXNlXCIsXG4gICAgcmVmZXJlbmNlOiB0b0xvd2VyQ2FzZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdG9NYXhWYWx1ZS90b01heFZhbHVlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdG9NYXhWYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX21heF92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogdG9NYXhWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUgPiB0aGlzLnJlcXVpcmVtZW50ID8gdGhpcy5yZXF1aXJlbWVudCA6IGRhdGFzZXQudmFsdWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RvTWluVmFsdWUvdG9NaW5WYWx1ZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRvTWluVmFsdWUocmVxdWlyZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0b19taW5fdmFsdWVcIixcbiAgICByZWZlcmVuY2U6IHRvTWluVmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlIDwgdGhpcy5yZXF1aXJlbWVudCA/IHRoaXMucmVxdWlyZW1lbnQgOiBkYXRhc2V0LnZhbHVlO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90b1VwcGVyQ2FzZS90b1VwcGVyQ2FzZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX3VwcGVyX2Nhc2VcIixcbiAgICByZWZlcmVuY2U6IHRvVXBwZXJDYXNlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90cmFuc2Zvcm0vdHJhbnNmb3JtLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdHJhbnNmb3JtKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogdHJhbnNmb3JtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcGVyYXRpb24sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IHRoaXMub3BlcmF0aW9uKGRhdGFzZXQudmFsdWUpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90cmFuc2Zvcm0vdHJhbnNmb3JtQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0cmFuc2Zvcm1Bc3luYyhvcGVyYXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmFuc2Zvcm1cIixcbiAgICByZWZlcmVuY2U6IHRyYW5zZm9ybUFzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wZXJhdGlvbixcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gYXdhaXQgdGhpcy5vcGVyYXRpb24oZGF0YXNldC52YWx1ZSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyaW0vdHJpbS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHRyaW0oKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidHJpbVwiLFxuICAgIHJlZmVyZW5jZTogdHJpbSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUudHJpbSgpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90cmltRW5kL3RyaW1FbmQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0cmltRW5kKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyaW1fZW5kXCIsXG4gICAgcmVmZXJlbmNlOiB0cmltRW5kLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50cmltRW5kKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyaW1TdGFydC90cmltU3RhcnQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0cmltU3RhcnQoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidHJpbV9zdGFydFwiLFxuICAgIHJlZmVyZW5jZTogdHJpbVN0YXJ0LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50cmltU3RhcnQoKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdWxpZC91bGlkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdWxpZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJ1bGlkXCIsXG4gICAgcmVmZXJlbmNlOiB1bGlkLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBVTElEX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJVTElEXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy91cmwvdXJsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdXJsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInVybFwiLFxuICAgIHJlZmVyZW5jZTogdXJsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50KGlucHV0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgVVJMKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJVUkxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3V1aWQvdXVpZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHV1aWQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwidXVpZFwiLFxuICAgIHJlZmVyZW5jZTogdXVpZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogVVVJRF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiVVVJRFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdmFsdWUvdmFsdWUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB2YWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICByZWZlcmVuY2U6IHZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgISh0aGlzLnJlcXVpcmVtZW50IDw9IGRhdGFzZXQudmFsdWUgJiYgdGhpcy5yZXF1aXJlbWVudCA+PSBkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3ZhbHVlcy92YWx1ZXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB2YWx1ZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInZhbHVlc1wiLFxuICAgIHJlZmVyZW5jZTogdmFsdWVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtfam9pbkV4cGVjdHMoXG4gICAgICByZXF1aXJlbWVudC5tYXAoXG4gICAgICAgICh2YWx1ZTIpID0+IHZhbHVlMiBpbnN0YW5jZW9mIERhdGUgPyB2YWx1ZTIudG9KU09OKCkgOiBfc3RyaW5naWZ5KHZhbHVlMilcbiAgICAgICksXG4gICAgICBcInxcIlxuICAgICl9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnNvbWUoXG4gICAgICAgICh2YWx1ZTIpID0+IHZhbHVlMiA8PSBkYXRhc2V0LnZhbHVlICYmIHZhbHVlMiA+PSBkYXRhc2V0LnZhbHVlXG4gICAgICApKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvd29yZHMvd29yZHMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB3b3Jkcyhsb2NhbGVzLCByZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwid29yZHNcIixcbiAgICByZWZlcmVuY2U6IHdvcmRzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgJHtyZXF1aXJlbWVudH1gLFxuICAgIGxvY2FsZXMsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBjb3VudCA9IF9nZXRXb3JkQ291bnQodGhpcy5sb2NhbGVzLCBkYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgaWYgKGNvdW50ICE9PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwid29yZHNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2NvdW50fWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9hc3NlcnQvYXNzZXJ0LnRzXG5mdW5jdGlvbiBhc3NlcnQoc2NoZW1hLCBpbnB1dCkge1xuICBjb25zdCBpc3N1ZXMgPSBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0IH0sIHsgYWJvcnRFYXJseTogdHJ1ZSB9KS5pc3N1ZXM7XG4gIGlmIChpc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaUVycm9yKGlzc3Vlcyk7XG4gIH1cbn1cblxuLy8gc3JjL21ldGhvZHMvY29uZmlnL2NvbmZpZy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGNvbmZpZyhzY2hlbWEsIGNvbmZpZzIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWdfKSB7XG4gICAgICByZXR1cm4gc2NoZW1hW1wifnJ1blwiXShkYXRhc2V0LCB7IC4uLmNvbmZpZ18sIC4uLmNvbmZpZzIgfSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXRGYWxsYmFjay9nZXRGYWxsYmFjay50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGdldEZhbGxiYWNrKHNjaGVtYSwgZGF0YXNldCwgY29uZmlnMikge1xuICByZXR1cm4gdHlwZW9mIHNjaGVtYS5mYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZmFsbGJhY2soZGF0YXNldCwgY29uZmlnMilcbiAgKSA6IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgc2NoZW1hLmZhbGxiYWNrXG4gICk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZhbGxiYWNrL2ZhbGxiYWNrLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZmFsbGJhY2soc2NoZW1hLCBmYWxsYmFjazIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZmFsbGJhY2s6IGZhbGxiYWNrMixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IG91dHB1dERhdGFzZXQgPSBzY2hlbWFbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgcmV0dXJuIG91dHB1dERhdGFzZXQuaXNzdWVzID8geyB0eXBlZDogdHJ1ZSwgdmFsdWU6IGdldEZhbGxiYWNrKHRoaXMsIG91dHB1dERhdGFzZXQsIGNvbmZpZzIpIH0gOiBvdXRwdXREYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmFsbGJhY2svZmFsbGJhY2tBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZhbGxiYWNrQXN5bmMoc2NoZW1hLCBmYWxsYmFjazIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZmFsbGJhY2s6IGZhbGxiYWNrMixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IG91dHB1dERhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgcmV0dXJuIG91dHB1dERhdGFzZXQuaXNzdWVzID8ge1xuICAgICAgICB0eXBlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGF3YWl0IGdldEZhbGxiYWNrKHRoaXMsIG91dHB1dERhdGFzZXQsIGNvbmZpZzIpXG4gICAgICB9IDogb3V0cHV0RGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZsYXR0ZW4vZmxhdHRlbi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGZsYXR0ZW4oaXNzdWVzKSB7XG4gIGNvbnN0IGZsYXRFcnJvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBpc3N1ZSBvZiBpc3N1ZXMpIHtcbiAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgY29uc3QgZG90UGF0aCA9IGdldERvdFBhdGgoaXNzdWUpO1xuICAgICAgaWYgKGRvdFBhdGgpIHtcbiAgICAgICAgaWYgKCFmbGF0RXJyb3JzLm5lc3RlZCkge1xuICAgICAgICAgIGZsYXRFcnJvcnMubmVzdGVkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYXRFcnJvcnMubmVzdGVkW2RvdFBhdGhdKSB7XG4gICAgICAgICAgZmxhdEVycm9ycy5uZXN0ZWRbZG90UGF0aF0ucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZFtkb3RQYXRoXSA9IFtpc3N1ZS5tZXNzYWdlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZsYXRFcnJvcnMub3RoZXIpIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm90aGVyLnB1c2goaXNzdWUubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEVycm9ycy5vdGhlciA9IFtpc3N1ZS5tZXNzYWdlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmxhdEVycm9ycy5yb290KSB7XG4gICAgICAgIGZsYXRFcnJvcnMucm9vdC5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdEVycm9ycy5yb290ID0gW2lzc3VlLm1lc3NhZ2VdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmxhdEVycm9ycztcbn1cblxuLy8gc3JjL21ldGhvZHMvZm9yd2FyZC9mb3J3YXJkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZm9yd2FyZChhY3Rpb24sIHBhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hY3Rpb24sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgcHJldklzc3VlcyA9IGRhdGFzZXQuaXNzdWVzICYmIFsuLi5kYXRhc2V0Lmlzc3Vlc107XG4gICAgICBkYXRhc2V0ID0gYWN0aW9uW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgaWYgKCFwcmV2SXNzdWVzPy5pbmNsdWRlcyhpc3N1ZSkpIHtcbiAgICAgICAgICAgIGxldCBwYXRoSW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGF0aCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBwYXRoSW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdGhWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwYXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXRoSW5wdXQgPSBwYXRoVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZvcndhcmQvZm9yd2FyZEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZm9yd2FyZEFzeW5jKGFjdGlvbiwgcGF0aCkge1xuICByZXR1cm4ge1xuICAgIC4uLmFjdGlvbixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBwcmV2SXNzdWVzID0gZGF0YXNldC5pc3N1ZXMgJiYgWy4uLmRhdGFzZXQuaXNzdWVzXTtcbiAgICAgIGRhdGFzZXQgPSBhd2FpdCBhY3Rpb25bXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICBpZiAoIXByZXZJc3N1ZXM/LmluY2x1ZGVzKGlzc3VlKSkge1xuICAgICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXRoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhWYWx1ZSA9IHBhdGhJbnB1dFtrZXldO1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF0aElucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0aFZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC5wdXNoKHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhdGhJbnB1dCA9IHBhdGhWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RGVmYXVsdC9nZXREZWZhdWx0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEsIGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZGVmYXVsdChkYXRhc2V0LCBjb25maWcyKVxuICApIDogKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZGVmYXVsdFxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0cy9nZXREZWZhdWx0cy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGdldERlZmF1bHRzKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3Qgb2JqZWN0MiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgICBvYmplY3QyW2tleV0gPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdHMoc2NoZW1hLmVudHJpZXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3QyO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5pdGVtcy5tYXAoZ2V0RGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBnZXREZWZhdWx0KHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHRzL2dldERlZmF1bHRzQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0c0FzeW5jKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykubWFwKGFzeW5jIChba2V5LCB2YWx1ZTJdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGF3YWl0IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0c0FzeW5jKHZhbHVlMilcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNjaGVtYS5pdGVtcy5tYXAoZ2V0RGVmYXVsdHNBc3luYykpO1xuICB9XG4gIHJldHVybiBnZXREZWZhdWx0KHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrcy9nZXRGYWxsYmFja3MudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBnZXRGYWxsYmFja3Moc2NoZW1hKSB7XG4gIGlmIChcImVudHJpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBvYmplY3QyID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICAgIG9iamVjdDJba2V5XSA9IC8qIEBfX1BVUkVfXyAqLyBnZXRGYWxsYmFja3Moc2NoZW1hLmVudHJpZXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3QyO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5pdGVtcy5tYXAoZ2V0RmFsbGJhY2tzKTtcbiAgfVxuICByZXR1cm4gZ2V0RmFsbGJhY2soc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RmFsbGJhY2tzL2dldEZhbGxiYWNrc0FzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmFsbGJhY2tzQXN5bmMoc2NoZW1hKSB7XG4gIGlmIChcImVudHJpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXdhaXQgLyogQF9fUFVSRV9fICovIGdldEZhbGxiYWNrc0FzeW5jKHZhbHVlMilcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNjaGVtYS5pdGVtcy5tYXAoZ2V0RmFsbGJhY2tzQXN5bmMpKTtcbiAgfVxuICByZXR1cm4gZ2V0RmFsbGJhY2soc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvaXMvaXMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpcyhzY2hlbWEsIGlucHV0KSB7XG4gIHJldHVybiAhc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dCB9LCB7IGFib3J0RWFybHk6IHRydWUgfSkuaXNzdWVzO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hbnkvYW55LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJhbnlcIixcbiAgICByZWZlcmVuY2U6IGFueSxcbiAgICBleHBlY3RzOiBcImFueVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hcnJheS9hcnJheS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGFycmF5KGl0ZW0sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICByZWZlcmVuY2U6IGFycmF5LFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbSxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5pdGVtW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hcnJheS9hcnJheUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYXJyYXlBc3luYyhpdGVtLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgcmVmZXJlbmNlOiBhcnJheUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaW5wdXQubWFwKCh2YWx1ZTIpID0+IHRoaXMuaXRlbVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBpdGVtRGF0YXNldHMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gaXRlbURhdGFzZXRzW2tleV07XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJpZ2ludChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgIHJlZmVyZW5jZTogYmlnaW50LFxuICAgIGV4cGVjdHM6IFwiYmlnaW50XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ibG9iL2Jsb2IudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBibG9iKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYmxvYlwiLFxuICAgIHJlZmVyZW5jZTogYmxvYixcbiAgICBleHBlY3RzOiBcIkJsb2JcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Jvb2xlYW4vYm9vbGVhbi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGJvb2xlYW4obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgcmVmZXJlbmNlOiBib29sZWFuLFxuICAgIGV4cGVjdHM6IFwiYm9vbGVhblwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2N1c3RvbS9jdXN0b20udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBjdXN0b20oY2hlY2syLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgIHJlZmVyZW5jZTogY3VzdG9tLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBjaGVjazogY2hlY2syLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodGhpcy5jaGVjayhkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2N1c3RvbS9jdXN0b21Bc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGN1c3RvbUFzeW5jKGNoZWNrMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJjdXN0b21cIixcbiAgICByZWZlcmVuY2U6IGN1c3RvbUFzeW5jLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGNoZWNrOiBjaGVjazIsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChhd2FpdCB0aGlzLmNoZWNrKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvZGF0ZS9kYXRlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZGF0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImRhdGVcIixcbiAgICByZWZlcmVuY2U6IGRhdGUsXG4gICAgZXhwZWN0czogXCJEYXRlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgaWYgKCFpc05hTihkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6ICdcIkludmFsaWQgRGF0ZVwiJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9lbnVtL2VudW0udHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBlbnVtXyhlbnVtX18sIG1lc3NhZ2UpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBlbnVtX18pIHtcbiAgICBpZiAoYCR7K2tleX1gICE9PSBrZXkgfHwgdHlwZW9mIGVudW1fX1trZXldICE9PSBcInN0cmluZ1wiIHx8ICFPYmplY3QuaXMoZW51bV9fW2VudW1fX1trZXldXSwgK2tleSkpIHtcbiAgICAgIG9wdGlvbnMucHVzaChlbnVtX19ba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICByZWZlcmVuY2U6IGVudW1fLFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhvcHRpb25zLm1hcChfc3RyaW5naWZ5KSwgXCJ8XCIpLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnVtOiBlbnVtX18sXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlcyhkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2V4YWN0T3B0aW9uYWwvZXhhY3RPcHRpb25hbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZXhhY3Rfb3B0aW9uYWxcIixcbiAgICByZWZlcmVuY2U6IGV4YWN0T3B0aW9uYWwsXG4gICAgZXhwZWN0czogd3JhcHBlZC5leHBlY3RzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9leGFjdE9wdGlvbmFsL2V4YWN0T3B0aW9uYWxBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGV4YWN0T3B0aW9uYWxBc3luYyh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJleGFjdF9vcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogZXhhY3RPcHRpb25hbEFzeW5jLFxuICAgIGV4cGVjdHM6IHdyYXBwZWQuZXhwZWN0cyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9maWxlL2ZpbGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBmaWxlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgIHJlZmVyZW5jZTogZmlsZSxcbiAgICBleHBlY3RzOiBcIkZpbGVcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Z1bmN0aW9uL2Z1bmN0aW9uLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gZnVuY3Rpb25fKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICByZWZlcmVuY2U6IGZ1bmN0aW9uXyxcbiAgICBleHBlY3RzOiBcIkZ1bmN0aW9uXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2luc3RhbmNlL2luc3RhbmNlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gaW5zdGFuY2UoY2xhc3NfLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImluc3RhbmNlXCIsXG4gICAgcmVmZXJlbmNlOiBpbnN0YW5jZSxcbiAgICBleHBlY3RzOiBjbGFzc18ubmFtZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgY2xhc3M6IGNsYXNzXyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiB0aGlzLmNsYXNzKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L3V0aWxzL19tZXJnZS9fbWVyZ2UudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBfbWVyZ2UodmFsdWUxLCB2YWx1ZTIpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZTEgPT09IHR5cGVvZiB2YWx1ZTIpIHtcbiAgICBpZiAodmFsdWUxID09PSB2YWx1ZTIgfHwgdmFsdWUxIGluc3RhbmNlb2YgRGF0ZSAmJiB2YWx1ZTIgaW5zdGFuY2VvZiBEYXRlICYmICt2YWx1ZTEgPT09ICt2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZTEgfTtcbiAgICB9XG4gICAgaWYgKHZhbHVlMSAmJiB2YWx1ZTIgJiYgdmFsdWUxLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgdmFsdWUyLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlMikge1xuICAgICAgICBpZiAoa2V5IGluIHZhbHVlMSkge1xuICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSAvKiBAX19QVVJFX18gKi8gX21lcmdlKHZhbHVlMVtrZXldLCB2YWx1ZTJba2V5XSk7XG4gICAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZTFba2V5XSA9IGRhdGFzZXQudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUxW2tleV0gPSB2YWx1ZTJba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlMSB9O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZTEpICYmIEFycmF5LmlzQXJyYXkodmFsdWUyKSkge1xuICAgICAgaWYgKHZhbHVlMS5sZW5ndGggPT09IHZhbHVlMi5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZhbHVlMS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gLyogQF9fUFVSRV9fICovIF9tZXJnZSh2YWx1ZTFbaW5kZXhdLCB2YWx1ZTJbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlMVtpbmRleF0gPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZTEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaXNzdWU6IHRydWUgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L2ludGVyc2VjdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGludGVyc2VjdChvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIHJlZmVyZW5jZTogaW50ZXJzZWN0LFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhcbiAgICAgIG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSxcbiAgICAgIFwiJlwiXG4gICAgKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICBsZXQgb3V0cHV0cztcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0IH0sIGNvbmZpZzIpO1xuICAgICAgICAgIGlmIChvcHRpb25EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzLnB1c2goLi4ub3B0aW9uRGF0YXNldC5pc3N1ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBvcHRpb25EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0cykge1xuICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gob3B0aW9uRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRzID0gW29wdGlvbkRhdGFzZXQudmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBvdXRwdXRzWzBdO1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBvdXRwdXRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VEYXRhc2V0ID0gX21lcmdlKGRhdGFzZXQudmFsdWUsIG91dHB1dHNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChtZXJnZURhdGFzZXQuaXNzdWUpIHtcbiAgICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwidW5rbm93blwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBtZXJnZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9pbnRlcnNlY3QvaW50ZXJzZWN0QXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBpbnRlcnNlY3RBc3luYyhvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIHJlZmVyZW5jZTogaW50ZXJzZWN0QXN5bmMsXG4gICAgZXhwZWN0czogX2pvaW5FeHBlY3RzKFxuICAgICAgb3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpLFxuICAgICAgXCImXCJcbiAgICApLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5tYXAoKHNjaGVtYSkgPT4gc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dCB9LCBjb25maWcyKSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb25EYXRhc2V0IG9mIG9wdGlvbkRhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMucHVzaCguLi5vcHRpb25EYXRhc2V0Lmlzc3Vlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IG9wdGlvbkRhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIW9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXRzKSB7XG4gICAgICAgICAgICAgIG91dHB1dHMucHVzaChvcHRpb25EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dHB1dHMgPSBbb3B0aW9uRGF0YXNldC52YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IG91dHB1dHNbMF07XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IG91dHB1dHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZURhdGFzZXQgPSBfbWVyZ2UoZGF0YXNldC52YWx1ZSwgb3V0cHV0c1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKG1lcmdlRGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJ1bmtub3duXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZSA9IG1lcmdlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xhenkvbGF6eS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxhenkoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxhenlcIixcbiAgICByZWZlcmVuY2U6IGxhenksXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldHRlcixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldHRlcihkYXRhc2V0LnZhbHVlKVtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenlBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxhenlBc3luYyhnZXR0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibGF6eVwiLFxuICAgIHJlZmVyZW5jZTogbGF6eUFzeW5jLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldHRlcixcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXR0ZXIoZGF0YXNldC52YWx1ZSkpW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xpdGVyYWwvbGl0ZXJhbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxpdGVyYWwobGl0ZXJhbF8sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIHJlZmVyZW5jZTogbGl0ZXJhbCxcbiAgICBleHBlY3RzOiBfc3RyaW5naWZ5KGxpdGVyYWxfKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbF8sXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sb29zZU9iamVjdC9sb29zZU9iamVjdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxvb3NlT2JqZWN0KGVudHJpZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibG9vc2Vfb2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBsb29zZU9iamVjdCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlU2NoZW1hID0gdGhpcy5lbnRyaWVzW2tleV07XG4gICAgICAgICAgaWYgKGtleSBpbiBpbnB1dCB8fCAodmFsdWVTY2hlbWEudHlwZSA9PT0gXCJleGFjdF9vcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm51bGxpc2hcIikgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0ga2V5IGluIGlucHV0ID8gKFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICkgOiBnZXREZWZhdWx0KHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHZhbHVlU2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGtleSkgJiYgIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbG9vc2VPYmplY3QvbG9vc2VPYmplY3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxvb3NlT2JqZWN0QXN5bmMoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV9vYmplY3RcIixcbiAgICByZWZlcmVuY2U6IGxvb3NlT2JqZWN0QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgdmFsdWVTY2hlbWFdKSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB2YWx1ZVNjaGVtYS5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0ga2V5IGluIGlucHV0ID8gKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICkgOiBhd2FpdCBnZXREZWZhdWx0KHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIHZhbHVlU2NoZW1hLFxuICAgICAgICAgICAgICAgIGF3YWl0IHZhbHVlU2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBpbnB1dFtrZXldLFxuICAgICAgICAgICAgICB2YWx1ZVNjaGVtYSxcbiAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVTY2hlbWEsIHZhbHVlRGF0YXNldF0gb2YgdmFsdWVEYXRhc2V0cykge1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS5mYWxsYmFjayAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBhd2FpdCBnZXRGYWxsYmFjayh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJvcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBleHBlY3RlZDogYFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkpICYmICEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlVHVwbGUvbG9vc2VUdXBsZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIGxvb3NlVHVwbGUoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibG9vc2VfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IGxvb3NlVHVwbGUsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV1bXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpbnB1dFtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlVHVwbGUvbG9vc2VUdXBsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbG9vc2VUdXBsZUFzeW5jKGl0ZW1zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxvb3NlX3R1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiBsb29zZVR1cGxlQXN5bmMsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5pdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCB2YWx1ZTIsIGF3YWl0IGl0ZW1bXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKV07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIGl0ZW1EYXRhc2V0XSBvZiBpdGVtRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChsZXQga2V5ID0gdGhpcy5pdGVtcy5sZW5ndGg7IGtleSA8IGlucHV0Lmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpbnB1dFtrZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL21hcC9tYXAudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBtYXAoa2V5LCB2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibWFwXCIsXG4gICAgcmVmZXJlbmNlOiBtYXAsXG4gICAgZXhwZWN0czogXCJNYXBcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0S2V5LCBpbnB1dFZhbHVlXSBvZiBpbnB1dCkge1xuICAgICAgICAgIGNvbnN0IGtleURhdGFzZXQgPSB0aGlzLmtleVtcIn5ydW5cIl0oeyB2YWx1ZTogaW5wdXRLZXkgfSwgY29uZmlnMik7XG4gICAgICAgICAgaWYgKGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0ga2V5RGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMudmFsdWVbXCJ+cnVuXCJdKFxuICAgICAgICAgICAgeyB2YWx1ZTogaW5wdXRWYWx1ZSB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrZXlEYXRhc2V0LnR5cGVkIHx8ICF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5zZXQoa2V5RGF0YXNldC52YWx1ZSwgdmFsdWVEYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbWFwL21hcEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbWFwQXN5bmMoa2V5LCB2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibWFwXCIsXG4gICAgcmVmZXJlbmNlOiBtYXBBc3luYyxcbiAgICBleHBlY3RzOiBcIk1hcFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIFsuLi5pbnB1dF0ubWFwKFxuICAgICAgICAgICAgKFtpbnB1dEtleSwgaW5wdXRWYWx1ZV0pID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgaW5wdXRLZXksXG4gICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMua2V5W1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dEtleSB9LCBjb25maWcyKSxcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVtcIn5ydW5cIl0oeyB2YWx1ZTogaW5wdXRWYWx1ZSB9LCBjb25maWcyKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW1xuICAgICAgICAgIGlucHV0S2V5LFxuICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAga2V5RGF0YXNldCxcbiAgICAgICAgICB2YWx1ZURhdGFzZXRcbiAgICAgICAgXSBvZiBkYXRhc2V0cykge1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleURhdGFzZXQudHlwZWQgfHwgIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnNldChrZXlEYXRhc2V0LnZhbHVlLCB2YWx1ZURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uYW4vbmFuLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbmFuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibmFuXCIsXG4gICAgcmVmZXJlbmNlOiBuYW4sXG4gICAgZXhwZWN0czogXCJOYU5cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9uZXZlci9uZXZlci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG5ldmVyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICByZWZlcmVuY2U6IG5ldmVyLFxuICAgIGV4cGVjdHM6IFwibmV2ZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm9uTnVsbGFibGUod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxhYmxlLFxuICAgIGV4cGVjdHM6IFwiIW51bGxcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YXNldCA9IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsYWJsZS9ub25OdWxsYWJsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbm9uTnVsbGFibGVBc3luYyh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9udWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbm9uTnVsbGFibGVBc3luYyxcbiAgICBleHBlY3RzOiBcIiFudWxsXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZGF0YXNldCA9IGF3YWl0IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25OdWxsaXNoL25vbk51bGxpc2gudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub25OdWxsaXNoKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxpc2gsXG4gICAgZXhwZWN0czogXCIoIW51bGwgJiAhdW5kZWZpbmVkKVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoIShkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkpIHtcbiAgICAgICAgZGF0YXNldCA9IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub25OdWxsaXNoQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fbnVsbGlzaFwiLFxuICAgIHJlZmVyZW5jZTogbm9uTnVsbGlzaEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiKCFudWxsICYgIXVuZGVmaW5lZClcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoIShkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkpIHtcbiAgICAgICAgZGF0YXNldCA9IGF3YWl0IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub25PcHRpb25hbCh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9vcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogbm9uT3B0aW9uYWwsXG4gICAgZXhwZWN0czogXCIhdW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgZGF0YXNldCA9IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk9wdGlvbmFsL25vbk9wdGlvbmFsQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBub25PcHRpb25hbEFzeW5jKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX29wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBub25PcHRpb25hbEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgZGF0YXNldCA9IGF3YWl0IHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGwvbnVsbC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG51bGxfKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibnVsbFwiLFxuICAgIHJlZmVyZW5jZTogbnVsbF8sXG4gICAgZXhwZWN0czogXCJudWxsXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbnVsbGFibGUod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICByZWZlcmVuY2U6IG51bGxhYmxlLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbClgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsYWJsZS9udWxsYWJsZUFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gbnVsbGFibGVBc3luYyh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbnVsbGFibGVBc3luYyxcbiAgICBleHBlY3RzOiBgKCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGwpYCxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZFtcIn5ydW5cIl0oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2gudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBudWxsaXNoKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG51bGxpc2gsXG4gICAgZXhwZWN0czogYCgke3dyYXBwZWQuZXhwZWN0c30gfCBudWxsIHwgdW5kZWZpbmVkKWAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbGlzaC9udWxsaXNoQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBudWxsaXNoQXN5bmMod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibnVsbGlzaFwiLFxuICAgIHJlZmVyZW5jZTogbnVsbGlzaEFzeW5jLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbCB8IHVuZGVmaW5lZClgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgZGVmYXVsdDogZGVmYXVsdF8sXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVtYmVyL251bWJlci50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG51bWJlcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHJlZmVyZW5jZTogbnVtYmVyLFxuICAgIGV4cGVjdHM6IFwibnVtYmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAodHlwZW9mIGRhdGFzZXQudmFsdWUgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0L29iamVjdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9iamVjdChlbnRyaWVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0LFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSB0aGlzLmVudHJpZXNba2V5XTtcbiAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgdmFsdWVTY2hlbWEuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBrZXkgaW4gaW5wdXQgPyAoXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgaW5wdXRba2V5XVxuICAgICAgICAgICAgKSA6IGdldERlZmF1bHQodmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS5mYWxsYmFjayAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBnZXRGYWxsYmFjayh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJvcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBleHBlY3RlZDogYFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2tleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdC9vYmplY3RBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9iamVjdEFzeW5jKGVudHJpZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBvYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcykubWFwKGFzeW5jIChba2V5LCB2YWx1ZVNjaGVtYV0pID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gaW5wdXQgfHwgKHZhbHVlU2NoZW1hLnR5cGUgPT09IFwiZXhhY3Rfb3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm9wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJudWxsaXNoXCIpICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBrZXkgaW4gaW5wdXQgPyAoXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICAgKSA6IGF3YWl0IGdldERlZmF1bHQodmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgICAgYXdhaXQgdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGlucHV0W2tleV0sXG4gICAgICAgICAgICAgIHZhbHVlU2NoZW1hLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCB2YWx1ZVNjaGVtYSwgdmFsdWVEYXRhc2V0XSBvZiB2YWx1ZURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU2NoZW1hLmZhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IGF3YWl0IGdldEZhbGxiYWNrKHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU2NoZW1hLnR5cGUgIT09IFwiZXhhY3Rfb3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm9wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJudWxsaXNoXCIpIHtcbiAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImtleVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBgXCIke2tleX1cImAsXG4gICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vYmplY3RXaXRoUmVzdC9vYmplY3RXaXRoUmVzdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIG9iamVjdFdpdGhSZXN0KGVudHJpZXMsIHJlc3QsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0X3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0V2l0aFJlc3QsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW50cmllcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlU2NoZW1hID0gdGhpcy5lbnRyaWVzW2tleV07XG4gICAgICAgICAgaWYgKGtleSBpbiBpbnB1dCB8fCAodmFsdWVTY2hlbWEudHlwZSA9PT0gXCJleGFjdF9vcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm51bGxpc2hcIikgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0ga2V5IGluIGlucHV0ID8gKFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICkgOiBnZXREZWZhdWx0KHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHZhbHVlU2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGtleSkgJiYgIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLnJlc3RbXCJ+cnVuXCJdKFxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB7IHZhbHVlOiBpbnB1dFtrZXldIH0sXG4gICAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRba2V5XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdFdpdGhSZXN0L29iamVjdFdpdGhSZXN0QXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvYmplY3RXaXRoUmVzdEFzeW5jKGVudHJpZXMsIHJlc3QsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0X3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0V2l0aFJlc3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCBbbm9ybWFsRGF0YXNldHMsIHJlc3REYXRhc2V0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gSWYga2V5IGlzIHByZXNlbnQgb3IgaXRzIGFuIG9wdGlvbmFsIHNjaGVtYSB3aXRoIGEgZGVmYXVsdCB2YWx1ZSxcbiAgICAgICAgICAvLyBwYXJzZSBpbnB1dCBvZiBrZXkgb3IgZGVmYXVsdCB2YWx1ZSBhc3luY2hyb25vdXNseVxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5lbnRyaWVzKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlU2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoa2V5IGluIGlucHV0IHx8ICh2YWx1ZVNjaGVtYS50eXBlID09PSBcImV4YWN0X29wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwibnVsbGlzaFwiKSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGtleSBpbiBpbnB1dCA/IChcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICAgICApIDogYXdhaXQgZ2V0RGVmYXVsdCh2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICAgIHZhbHVlU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlucHV0W2tleV0sXG4gICAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLFxuICAgICAgICAgIC8vIFBhcnNlIG90aGVyIGVudHJpZXMgd2l0aCByZXN0IHNjaGVtYSBhc3luY2hyb25vdXNseVxuICAgICAgICAgIC8vIEhpbnQ6IFdlIGV4Y2x1ZGUgc3BlY2lmaWMga2V5cyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5wdXQpLmZpbHRlcihcbiAgICAgICAgICAgICAgKFtrZXldKSA9PiBfaXNWYWxpZE9iamVjdEtleShpbnB1dCwga2V5KSAmJiAhKGtleSBpbiB0aGlzLmVudHJpZXMpXG4gICAgICAgICAgICApLm1hcChcbiAgICAgICAgICAgICAgYXN5bmMgKFtrZXksIHZhbHVlMl0pID0+IFtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzdFtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVTY2hlbWEsIHZhbHVlRGF0YXNldF0gb2Ygbm9ybWFsRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gYXdhaXQgZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIHZhbHVlRGF0YXNldF0gb2YgcmVzdERhdGFzZXRzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb3B0aW9uYWwvb3B0aW9uYWwudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvcHRpb25hbCh3cmFwcGVkLCBkZWZhdWx0Xykge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogb3B0aW9uYWwsXG4gICAgZXhwZWN0czogYCgke3dyYXBwZWQuZXhwZWN0c30gfCB1bmRlZmluZWQpYCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29wdGlvbmFsL29wdGlvbmFsQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvcHRpb25hbEFzeW5jKHdyYXBwZWQsIGRlZmF1bHRfKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBvcHRpb25hbEFzeW5jLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgdW5kZWZpbmVkKWAsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3BpY2tsaXN0L3BpY2tsaXN0LnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGlja2xpc3Qob3B0aW9ucywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJwaWNrbGlzdFwiLFxuICAgIHJlZmVyZW5jZTogcGlja2xpc3QsXG4gICAgZXhwZWN0czogX2pvaW5FeHBlY3RzKG9wdGlvbnMubWFwKF9zdHJpbmdpZnkpLCBcInxcIiksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZXMoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9wcm9taXNlL3Byb21pc2UudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwcm9taXNlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicHJvbWlzZVwiLFxuICAgIHJlZmVyZW5jZTogcHJvbWlzZSxcbiAgICBleHBlY3RzOiBcIlByb21pc2VcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3JlY29yZC9yZWNvcmQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZWNvcmQoa2V5LCB2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgcmVmZXJlbmNlOiByZWNvcmQsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeUtleSBpbiBpbnB1dCkge1xuICAgICAgICAgIGlmIChfaXNWYWxpZE9iamVjdEtleShpbnB1dCwgZW50cnlLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeVZhbHVlID0gaW5wdXRbZW50cnlLZXldO1xuICAgICAgICAgICAgY29uc3Qga2V5RGF0YXNldCA9IHRoaXMua2V5W1wifnJ1blwiXSh7IHZhbHVlOiBlbnRyeUtleSB9LCBjb25maWcyKTtcbiAgICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IGVudHJ5S2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlbnRyeVZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2Yga2V5RGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0ga2V5RGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy52YWx1ZVtcIn5ydW5cIl0oXG4gICAgICAgICAgICAgIHsgdmFsdWU6IGVudHJ5VmFsdWUgfSxcbiAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiBlbnRyeUtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnlWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5RGF0YXNldC50eXBlZCB8fCAhdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5RGF0YXNldC52YWx1ZV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWNvcmQvcmVjb3JkQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZWNvcmRBc3luYyhrZXksIHZhbHVlMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICByZWZlcmVuY2U6IHJlY29yZEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbnB1dCkuZmlsdGVyKChba2V5Ml0pID0+IF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkyKSkubWFwKFxuICAgICAgICAgICAgKFtlbnRyeUtleSwgZW50cnlWYWx1ZV0pID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgZW50cnlLZXksXG4gICAgICAgICAgICAgIGVudHJ5VmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMua2V5W1wifnJ1blwiXSh7IHZhbHVlOiBlbnRyeUtleSB9LCBjb25maWcyKSxcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZVtcIn5ydW5cIl0oeyB2YWx1ZTogZW50cnlWYWx1ZSB9LCBjb25maWcyKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW1xuICAgICAgICAgIGVudHJ5S2V5LFxuICAgICAgICAgIGVudHJ5VmFsdWUsXG4gICAgICAgICAga2V5RGF0YXNldCxcbiAgICAgICAgICB2YWx1ZURhdGFzZXRcbiAgICAgICAgXSBvZiBkYXRhc2V0cykge1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogZW50cnlLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBlbnRyeVZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBlbnRyeUtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleURhdGFzZXQudHlwZWQgfHwgIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5RGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXlEYXRhc2V0LnZhbHVlXSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzZXQodmFsdWUyLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIHJlZmVyZW5jZTogc2V0LFxuICAgIGV4cGVjdHM6IFwiU2V0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXRWYWx1ZSBvZiBpbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMudmFsdWVbXCJ+cnVuXCJdKFxuICAgICAgICAgICAgeyB2YWx1ZTogaW5wdXRWYWx1ZSB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogbnVsbCxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLmFkZCh2YWx1ZURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zZXQvc2V0QXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzZXRBc3luYyh2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic2V0XCIsXG4gICAgcmVmZXJlbmNlOiBzZXRBc3luYyxcbiAgICBleHBlY3RzOiBcIlNldFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBbLi4uaW5wdXRdLm1hcChcbiAgICAgICAgICAgIGFzeW5jIChpbnB1dFZhbHVlKSA9PiBbXG4gICAgICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMudmFsdWVbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0VmFsdWUgfSwgY29uZmlnMilcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0VmFsdWUsIHZhbHVlRGF0YXNldF0gb2YgdmFsdWVEYXRhc2V0cykge1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IG51bGwsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5hZGQodmFsdWVEYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaWN0T2JqZWN0L3N0cmljdE9iamVjdC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHN0cmljdE9iamVjdChlbnRyaWVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInN0cmljdF9vYmplY3RcIixcbiAgICByZWZlcmVuY2U6IHN0cmljdE9iamVjdCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlU2NoZW1hID0gdGhpcy5lbnRyaWVzW2tleV07XG4gICAgICAgICAgaWYgKGtleSBpbiBpbnB1dCB8fCAodmFsdWVTY2hlbWEudHlwZSA9PT0gXCJleGFjdF9vcHRpb25hbFwiIHx8IHZhbHVlU2NoZW1hLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm51bGxpc2hcIikgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0ga2V5IGluIGlucHV0ID8gKFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICkgOiBnZXREZWZhdWx0KHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHZhbHVlU2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEuZmFsbGJhY2sgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gZ2V0RmFsbGJhY2sodmFsdWVTY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVTY2hlbWEudHlwZSAhPT0gXCJleGFjdF9vcHRpb25hbFwiICYmIHZhbHVlU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwia2V5XCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIGlucHV0OiBrZXksXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRba2V5XVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaWN0T2JqZWN0L3N0cmljdE9iamVjdEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc3RyaWN0T2JqZWN0QXN5bmMoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3Rfb2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RPYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcykubWFwKGFzeW5jIChba2V5LCB2YWx1ZVNjaGVtYV0pID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gaW5wdXQgfHwgKHZhbHVlU2NoZW1hLnR5cGUgPT09IFwiZXhhY3Rfb3B0aW9uYWxcIiB8fCB2YWx1ZVNjaGVtYS50eXBlID09PSBcIm9wdGlvbmFsXCIgfHwgdmFsdWVTY2hlbWEudHlwZSA9PT0gXCJudWxsaXNoXCIpICYmIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHZhbHVlU2NoZW1hLmRlZmF1bHQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBrZXkgaW4gaW5wdXQgPyAoXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlucHV0W2tleV1cbiAgICAgICAgICAgICAgKSA6IGF3YWl0IGdldERlZmF1bHQodmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgICAgYXdhaXQgdmFsdWVTY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgIGlucHV0W2tleV0sXG4gICAgICAgICAgICAgIHZhbHVlU2NoZW1hLFxuICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCB2YWx1ZVNjaGVtYSwgdmFsdWVEYXRhc2V0XSBvZiB2YWx1ZURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU2NoZW1hLmZhbGxiYWNrICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWVba2V5XSA9IGF3YWl0IGdldEZhbGxiYWNrKHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlU2NoZW1hLnR5cGUgIT09IFwiZXhhY3Rfb3B0aW9uYWxcIiAmJiB2YWx1ZVNjaGVtYS50eXBlICE9PSBcIm9wdGlvbmFsXCIgJiYgdmFsdWVTY2hlbWEudHlwZSAhPT0gXCJudWxsaXNoXCIpIHtcbiAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImtleVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiB2b2lkIDAsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBgXCIke2tleX1cImAsXG4gICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJrZXlcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIGlucHV0OiBrZXksXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRba2V5XVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaWN0VHVwbGUvc3RyaWN0VHVwbGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzdHJpY3RUdXBsZShpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3RfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IHN0cmljdFR1cGxlLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCB0aGlzLml0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5pdGVtc1trZXldW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGRhdGFzZXQuaXNzdWVzICYmIGNvbmZpZzIuYWJvcnRFYXJseSkgJiYgdGhpcy5pdGVtcy5sZW5ndGggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dFt0aGlzLml0ZW1zLmxlbmd0aF0sXG4gICAgICAgICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W3RoaXMuaXRlbXMubGVuZ3RoXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N0cmljdFR1cGxlL3N0cmljdFR1cGxlQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzdHJpY3RUdXBsZUFzeW5jKGl0ZW1zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInN0cmljdF90dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogc3RyaWN0VHVwbGVBc3luYyxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBjb25zdCBpdGVtRGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlMiwgYXdhaXQgaXRlbVtcIn5ydW5cIl0oeyB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIGl0ZW1EYXRhc2V0cykge1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShkYXRhc2V0Lmlzc3VlcyAmJiBjb25maWcyLmFib3J0RWFybHkpICYmIHRoaXMuaXRlbXMubGVuZ3RoIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXRbdGhpcy5pdGVtcy5sZW5ndGhdLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFt0aGlzLml0ZW1zLmxlbmd0aF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpbmcvc3RyaW5nLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc3RyaW5nKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpbmcsXG4gICAgZXhwZWN0czogXCJzdHJpbmdcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N5bWJvbC9zeW1ib2wudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzeW1ib2wobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICByZWZlcmVuY2U6IHN5bWJvbCxcbiAgICBleHBlY3RzOiBcInN5bWJvbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdHVwbGUvdHVwbGUudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0dXBsZShpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGUsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV1bXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlL3R1cGxlQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0dXBsZUFzeW5jKGl0ZW1zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgcmVmZXJlbmNlOiB0dXBsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXMubWFwKGFzeW5jIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWUyLCBhd2FpdCBpdGVtW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMildO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgaXRlbURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZVdpdGhSZXN0L3R1cGxlV2l0aFJlc3QudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB0dXBsZVdpdGhSZXN0KGl0ZW1zLCByZXN0LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlX3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGVXaXRoUmVzdCxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIHJlc3QsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCB0aGlzLml0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5pdGVtc1trZXldW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAobGV0IGtleSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLnJlc3RbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKTtcbiAgICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlV2l0aFJlc3QvdHVwbGVXaXRoUmVzdEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdHVwbGVXaXRoUmVzdEFzeW5jKGl0ZW1zLCByZXN0LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlX3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGVXaXRoUmVzdEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgW25vcm1hbERhdGFzZXRzLCByZXN0RGF0YXNldHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIFBhcnNlIHNjaGVtYSBvZiBlYWNoIG5vcm1hbCBpdGVtXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCBpdGVtW1wifnJ1blwiXSh7IHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBQYXJzZSBvdGhlciBpdGVtcyB3aXRoIHJlc3Qgc2NoZW1hXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpbnB1dC5zbGljZSh0aGlzLml0ZW1zLmxlbmd0aCkubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSArIHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3RbXCJ+cnVuXCJdKHsgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIG5vcm1hbERhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgcmVzdERhdGFzZXRzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWQvdW5kZWZpbmVkLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdW5kZWZpbmVkXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgIHJlZmVyZW5jZTogdW5kZWZpbmVkXyxcbiAgICBleHBlY3RzOiBcInVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuZGVmaW5lZGFibGUvdW5kZWZpbmVkYWJsZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVuZGVmaW5lZGFibGUod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5kZWZpbmVkYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogdW5kZWZpbmVkYWJsZSxcbiAgICBleHBlY3RzOiBgKCR7d3JhcHBlZC5leHBlY3RzfSB8IHVuZGVmaW5lZClgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRfLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gZ2V0RGVmYXVsdCh0aGlzLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWRbXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5kZWZpbmVkYWJsZS91bmRlZmluZWRhYmxlQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB1bmRlZmluZWRhYmxlQXN5bmMod3JhcHBlZCwgZGVmYXVsdF8pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5kZWZpbmVkYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogdW5kZWZpbmVkYWJsZUFzeW5jLFxuICAgIGV4cGVjdHM6IGAoJHt3cmFwcGVkLmV4cGVjdHN9IHwgdW5kZWZpbmVkKWAsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0XyxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIGFzeW5jIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQodGhpcywgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkW1wifnJ1blwiXShkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuaW9uL3V0aWxzL19zdWJJc3N1ZXMvX3N1Yklzc3Vlcy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIF9zdWJJc3N1ZXMoZGF0YXNldHMpIHtcbiAgbGV0IGlzc3VlcztcbiAgaWYgKGRhdGFzZXRzKSB7XG4gICAgZm9yIChjb25zdCBkYXRhc2V0IG9mIGRhdGFzZXRzKSB7XG4gICAgICBpZiAoaXNzdWVzKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKC4uLmRhdGFzZXQuaXNzdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzc3VlcyA9IGRhdGFzZXQuaXNzdWVzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaXNzdWVzO1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmlvbi91bmlvbi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICByZWZlcmVuY2U6IHVuaW9uLFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhcbiAgICAgIG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSxcbiAgICAgIFwifFwiXG4gICAgKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgbGV0IHZhbGlkRGF0YXNldDtcbiAgICAgIGxldCB0eXBlZERhdGFzZXRzO1xuICAgICAgbGV0IHVudHlwZWREYXRhc2V0cztcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHRoaXMub3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0ID0gc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBkYXRhc2V0LnZhbHVlIH0sIGNvbmZpZzIpO1xuICAgICAgICBpZiAob3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgIGlmIChvcHRpb25EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgICAgdHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZWREYXRhc2V0cyA9IFtvcHRpb25EYXRhc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodW50eXBlZERhdGFzZXRzKSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMucHVzaChvcHRpb25EYXRhc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW50eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHZhbGlkRGF0YXNldCkge1xuICAgICAgICByZXR1cm4gdmFsaWREYXRhc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgaWYgKHR5cGVkRGF0YXNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVkRGF0YXNldHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHR5cGVkRGF0YXNldHMpXG4gICAgICAgIH0pO1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodW50eXBlZERhdGFzZXRzPy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHVudHlwZWREYXRhc2V0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIGlzc3VlczogX3N1Yklzc3Vlcyh1bnR5cGVkRGF0YXNldHMpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmlvbi91bmlvbkFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdW5pb25Bc3luYyhvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgcmVmZXJlbmNlOiB1bmlvbkFzeW5jLFxuICAgIGV4cGVjdHM6IF9qb2luRXhwZWN0cyhcbiAgICAgIG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSxcbiAgICAgIFwifFwiXG4gICAgKSxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfSxcbiAgICBhc3luYyBcIn5ydW5cIihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBsZXQgdmFsaWREYXRhc2V0O1xuICAgICAgbGV0IHR5cGVkRGF0YXNldHM7XG4gICAgICBsZXQgdW50eXBlZERhdGFzZXRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKFxuICAgICAgICAgIHsgdmFsdWU6IGRhdGFzZXQudmFsdWUgfSxcbiAgICAgICAgICBjb25maWcyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzLnB1c2gob3B0aW9uRGF0YXNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1bnR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgIHVudHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMgPSBbb3B0aW9uRGF0YXNldF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWREYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZERhdGFzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICBpZiAodHlwZWREYXRhc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZWREYXRhc2V0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpc3N1ZXM6IF9zdWJJc3N1ZXModHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1bnR5cGVkRGF0YXNldHM/Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdW50eXBlZERhdGFzZXRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHVudHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3Vua25vd24vdW5rbm93bi50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInVua25vd25cIixcbiAgICByZWZlcmVuY2U6IHVua25vd24sXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHZhcmlhbnQoa2V5LCBvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInZhcmlhbnRcIixcbiAgICByZWZlcmVuY2U6IHZhcmlhbnQsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9LFxuICAgIFwifnJ1blwiKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbGV0IG91dHB1dERhdGFzZXQ7XG4gICAgICAgIGxldCBtYXhEaXNjcmltaW5hdG9yUHJpb3JpdHkgPSAwO1xuICAgICAgICBsZXQgaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgPSB0aGlzLmtleTtcbiAgICAgICAgbGV0IGV4cGVjdGVkRGlzY3JpbWluYXRvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFyc2VPcHRpb25zID0gKHZhcmlhbnQyLCBhbGxLZXlzKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdmFyaWFudDIub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS50eXBlID09PSBcInZhcmlhbnRcIikge1xuICAgICAgICAgICAgICBwYXJzZU9wdGlvbnMoc2NoZW1hLCBuZXcgU2V0KGFsbEtleXMpLmFkZChzY2hlbWEua2V5KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQga2V5c0FyZVZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRQcmlvcml0eSA9IDA7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgY3VycmVudEtleSBvZiBhbGxLZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclNjaGVtYSA9IHNjaGVtYS5lbnRyaWVzW2N1cnJlbnRLZXldO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50S2V5IGluIGlucHV0ID8gZGlzY3JpbWluYXRvclNjaGVtYVtcIn5ydW5cIl0oXG4gICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0W2N1cnJlbnRLZXldIH0sXG4gICAgICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICAgICAgKS5pc3N1ZXMgOiBkaXNjcmltaW5hdG9yU2NoZW1hLnR5cGUgIT09IFwiZXhhY3Rfb3B0aW9uYWxcIiAmJiBkaXNjcmltaW5hdG9yU2NoZW1hLnR5cGUgIT09IFwib3B0aW9uYWxcIiAmJiBkaXNjcmltaW5hdG9yU2NoZW1hLnR5cGUgIT09IFwibnVsbGlzaFwiKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzQXJlVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkRGlzY3JpbWluYXRvcktleSAhPT0gY3VycmVudEtleSAmJiAobWF4RGlzY3JpbWluYXRvclByaW9yaXR5IDwgY3VycmVudFByaW9yaXR5IHx8IG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA9PT0gY3VycmVudFByaW9yaXR5ICYmIGN1cnJlbnRLZXkgaW4gaW5wdXQgJiYgIShpbnZhbGlkRGlzY3JpbWluYXRvcktleSBpbiBpbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA9IGN1cnJlbnRQcmlvcml0eTtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgPSBjdXJyZW50S2V5O1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZERpc2NyaW1pbmF0b3JzID0gW107XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgPT09IGN1cnJlbnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWREaXNjcmltaW5hdG9ycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYS5lbnRyaWVzW2N1cnJlbnRLZXldLmV4cGVjdHNcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHkrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoa2V5c0FyZVZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRGF0YXNldCA9IHNjaGVtYVtcIn5ydW5cIl0oeyB2YWx1ZTogaW5wdXQgfSwgY29uZmlnMik7XG4gICAgICAgICAgICAgICAgaWYgKCFvdXRwdXREYXRhc2V0IHx8ICFvdXRwdXREYXRhc2V0LnR5cGVkICYmIG9wdGlvbkRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHB1dERhdGFzZXQgJiYgIW91dHB1dERhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGFyc2VPcHRpb25zKHRoaXMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFt0aGlzLmtleV0pKTtcbiAgICAgICAgaWYgKG91dHB1dERhdGFzZXQpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0RGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgaW5wdXQ6IGlucHV0W2ludmFsaWREaXNjcmltaW5hdG9yS2V5XSxcbiAgICAgICAgICBleHBlY3RlZDogX2pvaW5FeHBlY3RzKGV4cGVjdGVkRGlzY3JpbWluYXRvcnMsIFwifFwiKSxcbiAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnZhbGlkRGlzY3JpbWluYXRvcktleSxcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRbaW52YWxpZERpc2NyaW1pbmF0b3JLZXldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3ZhcmlhbnQvdmFyaWFudEFzeW5jLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gdmFyaWFudEFzeW5jKGtleSwgb3B0aW9ucywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ2YXJpYW50XCIsXG4gICAgcmVmZXJlbmNlOiB2YXJpYW50QXN5bmMsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBrZXksXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgb3V0cHV0RGF0YXNldDtcbiAgICAgICAgbGV0IG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA9IDA7XG4gICAgICAgIGxldCBpbnZhbGlkRGlzY3JpbWluYXRvcktleSA9IHRoaXMua2V5O1xuICAgICAgICBsZXQgZXhwZWN0ZWREaXNjcmltaW5hdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBwYXJzZU9wdGlvbnMgPSBhc3luYyAodmFyaWFudDIsIGFsbEtleXMpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB2YXJpYW50Mi5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwidmFyaWFudFwiKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHBhcnNlT3B0aW9ucyhzY2hlbWEsIG5ldyBTZXQoYWxsS2V5cykuYWRkKHNjaGVtYS5rZXkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBrZXlzQXJlVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICBsZXQgY3VycmVudFByaW9yaXR5ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBjdXJyZW50S2V5IG9mIGFsbEtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gc2NoZW1hLmVudHJpZXNbY3VycmVudEtleV07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRLZXkgaW4gaW5wdXQgPyAoYXdhaXQgZGlzY3JpbWluYXRvclNjaGVtYVtcIn5ydW5cIl0oXG4gICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0W2N1cnJlbnRLZXldIH0sXG4gICAgICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICAgICAgKSkuaXNzdWVzIDogZGlzY3JpbWluYXRvclNjaGVtYS50eXBlICE9PSBcImV4YWN0X29wdGlvbmFsXCIgJiYgZGlzY3JpbWluYXRvclNjaGVtYS50eXBlICE9PSBcIm9wdGlvbmFsXCIgJiYgZGlzY3JpbWluYXRvclNjaGVtYS50eXBlICE9PSBcIm51bGxpc2hcIikge1xuICAgICAgICAgICAgICAgICAga2V5c0FyZVZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgIT09IGN1cnJlbnRLZXkgJiYgKG1heERpc2NyaW1pbmF0b3JQcmlvcml0eSA8IGN1cnJlbnRQcmlvcml0eSB8fCBtYXhEaXNjcmltaW5hdG9yUHJpb3JpdHkgPT09IGN1cnJlbnRQcmlvcml0eSAmJiBjdXJyZW50S2V5IGluIGlucHV0ICYmICEoaW52YWxpZERpc2NyaW1pbmF0b3JLZXkgaW4gaW5wdXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhEaXNjcmltaW5hdG9yUHJpb3JpdHkgPSBjdXJyZW50UHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWREaXNjcmltaW5hdG9yS2V5ID0gY3VycmVudEtleTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWREaXNjcmltaW5hdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGludmFsaWREaXNjcmltaW5hdG9yS2V5ID09PSBjdXJyZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkRGlzY3JpbWluYXRvcnMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEuZW50cmllc1tjdXJyZW50S2V5XS5leHBlY3RzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFByaW9yaXR5Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGtleXNBcmVWYWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKFxuICAgICAgICAgICAgICAgICAgeyB2YWx1ZTogaW5wdXQgfSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0RGF0YXNldCB8fCAhb3V0cHV0RGF0YXNldC50eXBlZCAmJiBvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXREYXRhc2V0ID0gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXREYXRhc2V0ICYmICFvdXRwdXREYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHBhcnNlT3B0aW9ucyh0aGlzLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbdGhpcy5rZXldKSk7XG4gICAgICAgIGlmIChvdXRwdXREYXRhc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dERhdGFzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGlucHV0OiBpbnB1dFtpbnZhbGlkRGlzY3JpbWluYXRvcktleV0sXG4gICAgICAgICAgZXhwZWN0ZWQ6IF9qb2luRXhwZWN0cyhleHBlY3RlZERpc2NyaW1pbmF0b3JzLCBcInxcIiksXG4gICAgICAgICAgcGF0aDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW52YWxpZERpc2NyaW1pbmF0b3JLZXksXG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2ludmFsaWREaXNjcmltaW5hdG9yS2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy92b2lkL3ZvaWQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiB2b2lkXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInZvaWRcIixcbiAgICByZWZlcmVuY2U6IHZvaWRfLFxuICAgIGV4cGVjdHM6IFwidm9pZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2tleW9mL2tleW9mLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24ga2V5b2Yoc2NoZW1hLCBtZXNzYWdlKSB7XG4gIHJldHVybiBwaWNrbGlzdChPYmplY3Qua2V5cyhzY2hlbWEuZW50cmllcyksIG1lc3NhZ2UpO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9vbWl0L29taXQudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwga2V5cykge1xuICBjb25zdCBlbnRyaWVzID0ge1xuICAgIC4uLnNjaGVtYS5lbnRyaWVzXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgZW50cmllc1trZXldO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIGVudHJpZXMsXG4gICAgZ2V0IFwifnN0YW5kYXJkXCIoKSB7XG4gICAgICByZXR1cm4gX2dldFN0YW5kYXJkUHJvcHModGhpcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJzZS9wYXJzZS50c1xuZnVuY3Rpb24gcGFyc2Uoc2NoZW1hLCBpbnB1dCwgY29uZmlnMikge1xuICBjb25zdCBkYXRhc2V0ID0gc2NoZW1hW1wifnJ1blwiXSh7IHZhbHVlOiBpbnB1dCB9LCBnZXRHbG9iYWxDb25maWcoY29uZmlnMikpO1xuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaUVycm9yKGRhdGFzZXQuaXNzdWVzKTtcbiAgfVxuICByZXR1cm4gZGF0YXNldC52YWx1ZTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBc3luYyhzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCBzY2hlbWFbXCJ+cnVuXCJdKFxuICAgIHsgdmFsdWU6IGlucHV0IH0sXG4gICAgZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZzIpXG4gICk7XG4gIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IoZGF0YXNldC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiBkYXRhc2V0LnZhbHVlO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJzZXIvcGFyc2VyLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGFyc2VyKHNjaGVtYSwgY29uZmlnMikge1xuICBjb25zdCBmdW5jID0gKGlucHV0KSA9PiBwYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKTtcbiAgZnVuYy5zY2hlbWEgPSBzY2hlbWE7XG4gIGZ1bmMuY29uZmlnID0gY29uZmlnMjtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnNlci9wYXJzZXJBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHBhcnNlckFzeW5jKHNjaGVtYSwgY29uZmlnMikge1xuICBjb25zdCBmdW5jID0gKGlucHV0KSA9PiBwYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFydGlhbC9wYXJ0aWFsLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGtleXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgIGVudHJpZXNba2V5XSA9ICFrZXlzIHx8IGtleXMuaW5jbHVkZXMoa2V5KSA/IG9wdGlvbmFsKHNjaGVtYS5lbnRyaWVzW2tleV0pIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBlbnRyaWVzLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFydGlhbC9wYXJ0aWFsQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBwYXJ0aWFsQXN5bmMoc2NoZW1hLCBrZXlzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBvcHRpb25hbEFzeW5jKHNjaGVtYS5lbnRyaWVzW2tleV0pIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBlbnRyaWVzLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGljay9waWNrLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGljayhzY2hlbWEsIGtleXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZW50cmllc1trZXldID0gc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBlbnRyaWVzLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGlwZS9waXBlLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gcGlwZSguLi5waXBlMikge1xuICByZXR1cm4ge1xuICAgIC4uLnBpcGUyWzBdLFxuICAgIHBpcGU6IHBpcGUyLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBpcGUyKSB7XG4gICAgICAgIGlmIChpdGVtLmtpbmQgIT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3VlcyAmJiAoaXRlbS5raW5kID09PSBcInNjaGVtYVwiIHx8IGl0ZW0ua2luZCA9PT0gXCJ0cmFuc2Zvcm1hdGlvblwiKSkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSAmJiAhY29uZmlnMi5hYm9ydFBpcGVFYXJseSkge1xuICAgICAgICAgICAgZGF0YXNldCA9IGl0ZW1bXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waXBlL3BpcGVBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHBpcGVBc3luYyguLi5waXBlMikge1xuICByZXR1cm4ge1xuICAgIC4uLnBpcGUyWzBdLFxuICAgIHBpcGU6IHBpcGUyLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH0sXG4gICAgYXN5bmMgXCJ+cnVuXCIoZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBpcGUyKSB7XG4gICAgICAgIGlmIChpdGVtLmtpbmQgIT09IFwibWV0YWRhdGFcIikge1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3VlcyAmJiAoaXRlbS5raW5kID09PSBcInNjaGVtYVwiIHx8IGl0ZW0ua2luZCA9PT0gXCJ0cmFuc2Zvcm1hdGlvblwiKSkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSAmJiAhY29uZmlnMi5hYm9ydFBpcGVFYXJseSkge1xuICAgICAgICAgICAgZGF0YXNldCA9IGF3YWl0IGl0ZW1bXCJ+cnVuXCJdKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHJlcXVpcmVkKHNjaGVtYSwgYXJnMiwgYXJnMykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShhcmcyKSA/IGFyZzIgOiB2b2lkIDA7XG4gIGNvbnN0IG1lc3NhZ2UgPSBBcnJheS5pc0FycmF5KGFyZzIpID8gYXJnMyA6IGFyZzI7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBub25PcHRpb25hbChzY2hlbWEuZW50cmllc1trZXldLCBtZXNzYWdlKSA6IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZW50cmllcyxcbiAgICBnZXQgXCJ+c3RhbmRhcmRcIigpIHtcbiAgICAgIHJldHVybiBfZ2V0U3RhbmRhcmRQcm9wcyh0aGlzKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3JlcXVpcmVkL3JlcXVpcmVkQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiByZXF1aXJlZEFzeW5jKHNjaGVtYSwgYXJnMiwgYXJnMykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShhcmcyKSA/IGFyZzIgOiB2b2lkIDA7XG4gIGNvbnN0IG1lc3NhZ2UgPSBBcnJheS5pc0FycmF5KGFyZzIpID8gYXJnMyA6IGFyZzI7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBub25PcHRpb25hbEFzeW5jKHNjaGVtYS5lbnRyaWVzW2tleV0sIG1lc3NhZ2UpIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBlbnRyaWVzLFxuICAgIGdldCBcIn5zdGFuZGFyZFwiKCkge1xuICAgICAgcmV0dXJuIF9nZXRTdGFuZGFyZFByb3BzKHRoaXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlL3NhZmVQYXJzZS50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHNhZmVQYXJzZShzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBzY2hlbWFbXCJ+cnVuXCJdKHsgdmFsdWU6IGlucHV0IH0sIGdldEdsb2JhbENvbmZpZyhjb25maWcyKSk7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IGRhdGFzZXQudHlwZWQsXG4gICAgc3VjY2VzczogIWRhdGFzZXQuaXNzdWVzLFxuICAgIG91dHB1dDogZGF0YXNldC52YWx1ZSxcbiAgICBpc3N1ZXM6IGRhdGFzZXQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZS9zYWZlUGFyc2VBc3luYy50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmFzeW5jIGZ1bmN0aW9uIHNhZmVQYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpIHtcbiAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHNjaGVtYVtcIn5ydW5cIl0oXG4gICAgeyB2YWx1ZTogaW5wdXQgfSxcbiAgICBnZXRHbG9iYWxDb25maWcoY29uZmlnMilcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogZGF0YXNldC50eXBlZCxcbiAgICBzdWNjZXNzOiAhZGF0YXNldC5pc3N1ZXMsXG4gICAgb3V0cHV0OiBkYXRhc2V0LnZhbHVlLFxuICAgIGlzc3VlczogZGF0YXNldC5pc3N1ZXNcbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlci9zYWZlUGFyc2VyLnRzXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gc2FmZVBhcnNlcihzY2hlbWEsIGNvbmZpZzIpIHtcbiAgY29uc3QgZnVuYyA9IChpbnB1dCkgPT4gc2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlci9zYWZlUGFyc2VyQXN5bmMudHNcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBzYWZlUGFyc2VyQXN5bmMoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHNhZmVQYXJzZUFzeW5jKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvdW53cmFwL3Vud3JhcC50c1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIHVud3JhcChzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYS53cmFwcGVkO1xufVxuZXhwb3J0IHtcbiAgQkFTRTY0X1JFR0VYLFxuICBCSUNfUkVHRVgsXG4gIENVSUQyX1JFR0VYLFxuICBERUNJTUFMX1JFR0VYLFxuICBESUdJVFNfUkVHRVgsXG4gIEVNQUlMX1JFR0VYLFxuICBFTU9KSV9SRUdFWCxcbiAgSEVYQURFQ0lNQUxfUkVHRVgsXG4gIEhFWF9DT0xPUl9SRUdFWCxcbiAgSU1FSV9SRUdFWCxcbiAgSVBWNF9SRUdFWCxcbiAgSVBWNl9SRUdFWCxcbiAgSVBfUkVHRVgsXG4gIElTT19EQVRFX1JFR0VYLFxuICBJU09fREFURV9USU1FX1JFR0VYLFxuICBJU09fVElNRVNUQU1QX1JFR0VYLFxuICBJU09fVElNRV9SRUdFWCxcbiAgSVNPX1RJTUVfU0VDT05EX1JFR0VYLFxuICBJU09fV0VFS19SRUdFWCxcbiAgTUFDNDhfUkVHRVgsXG4gIE1BQzY0X1JFR0VYLFxuICBNQUNfUkVHRVgsXG4gIE5BTk9fSURfUkVHRVgsXG4gIE9DVEFMX1JFR0VYLFxuICBSRkNfRU1BSUxfUkVHRVgsXG4gIFNMVUdfUkVHRVgsXG4gIFVMSURfUkVHRVgsXG4gIFVVSURfUkVHRVgsXG4gIFZhbGlFcnJvcixcbiAgX2FkZElzc3VlLFxuICBfZ2V0Qnl0ZUNvdW50LFxuICBfZ2V0R3JhcGhlbWVDb3VudCxcbiAgX2dldFN0YW5kYXJkUHJvcHMsXG4gIF9nZXRXb3JkQ291bnQsXG4gIF9pc0x1aG5BbGdvLFxuICBfaXNWYWxpZE9iamVjdEtleSxcbiAgX2pvaW5FeHBlY3RzLFxuICBfc3RyaW5naWZ5LFxuICBhbnksXG4gIGFyZ3MsXG4gIGFyZ3NBc3luYyxcbiAgYXJyYXksXG4gIGFycmF5QXN5bmMsXG4gIGFzc2VydCxcbiAgYXdhaXRBc3luYyxcbiAgYmFzZTY0LFxuICBiaWMsXG4gIGJpZ2ludCxcbiAgYmxvYixcbiAgYm9vbGVhbixcbiAgYnJhbmQsXG4gIGJ5dGVzLFxuICBjaGVjayxcbiAgY2hlY2tBc3luYyxcbiAgY2hlY2tJdGVtcyxcbiAgY2hlY2tJdGVtc0FzeW5jLFxuICBjb25maWcsXG4gIGNyZWRpdENhcmQsXG4gIGN1aWQyLFxuICBjdXN0b20sXG4gIGN1c3RvbUFzeW5jLFxuICBkYXRlLFxuICBkZWNpbWFsLFxuICBkZWxldGVHbG9iYWxDb25maWcsXG4gIGRlbGV0ZUdsb2JhbE1lc3NhZ2UsXG4gIGRlbGV0ZVNjaGVtYU1lc3NhZ2UsXG4gIGRlbGV0ZVNwZWNpZmljTWVzc2FnZSxcbiAgZGVzY3JpcHRpb24sXG4gIGRpZ2l0cyxcbiAgZW1haWwsXG4gIGVtb2ppLFxuICBlbXB0eSxcbiAgZW5kc1dpdGgsXG4gIGVudHJpZXNGcm9tTGlzdCxcbiAgZW50cmllc0Zyb21PYmplY3RzLFxuICBlbnVtXyBhcyBlbnVtLFxuICBlbnVtXyxcbiAgZXZlcnlJdGVtLFxuICBleGFjdE9wdGlvbmFsLFxuICBleGFjdE9wdGlvbmFsQXN5bmMsXG4gIGV4Y2x1ZGVzLFxuICBmYWxsYmFjayxcbiAgZmFsbGJhY2tBc3luYyxcbiAgZmlsZSxcbiAgZmlsdGVySXRlbXMsXG4gIGZpbmRJdGVtLFxuICBmaW5pdGUsXG4gIGZsYXR0ZW4sXG4gIGZvcndhcmQsXG4gIGZvcndhcmRBc3luYyxcbiAgZnVuY3Rpb25fIGFzIGZ1bmN0aW9uLFxuICBmdW5jdGlvbl8sXG4gIGdldERlZmF1bHQsXG4gIGdldERlZmF1bHRzLFxuICBnZXREZWZhdWx0c0FzeW5jLFxuICBnZXREb3RQYXRoLFxuICBnZXRGYWxsYmFjayxcbiAgZ2V0RmFsbGJhY2tzLFxuICBnZXRGYWxsYmFja3NBc3luYyxcbiAgZ2V0R2xvYmFsQ29uZmlnLFxuICBnZXRHbG9iYWxNZXNzYWdlLFxuICBnZXRTY2hlbWFNZXNzYWdlLFxuICBnZXRTcGVjaWZpY01lc3NhZ2UsXG4gIGdyYXBoZW1lcyxcbiAgZ3RWYWx1ZSxcbiAgaGFzaCxcbiAgaGV4Q29sb3IsXG4gIGhleGFkZWNpbWFsLFxuICBpbWVpLFxuICBpbmNsdWRlcyxcbiAgaW5zdGFuY2UsXG4gIGludGVnZXIsXG4gIGludGVyc2VjdCxcbiAgaW50ZXJzZWN0QXN5bmMsXG4gIGlwLFxuICBpcHY0LFxuICBpcHY2LFxuICBpcyxcbiAgaXNPZktpbmQsXG4gIGlzT2ZUeXBlLFxuICBpc1ZhbGlFcnJvcixcbiAgaXNvRGF0ZSxcbiAgaXNvRGF0ZVRpbWUsXG4gIGlzb1RpbWUsXG4gIGlzb1RpbWVTZWNvbmQsXG4gIGlzb1RpbWVzdGFtcCxcbiAgaXNvV2VlayxcbiAga2V5b2YsXG4gIGxhenksXG4gIGxhenlBc3luYyxcbiAgbGVuZ3RoLFxuICBsaXRlcmFsLFxuICBsb29zZU9iamVjdCxcbiAgbG9vc2VPYmplY3RBc3luYyxcbiAgbG9vc2VUdXBsZSxcbiAgbG9vc2VUdXBsZUFzeW5jLFxuICBsdFZhbHVlLFxuICBtYWMsXG4gIG1hYzQ4LFxuICBtYWM2NCxcbiAgbWFwLFxuICBtYXBBc3luYyxcbiAgbWFwSXRlbXMsXG4gIG1heEJ5dGVzLFxuICBtYXhHcmFwaGVtZXMsXG4gIG1heExlbmd0aCxcbiAgbWF4U2l6ZSxcbiAgbWF4VmFsdWUsXG4gIG1heFdvcmRzLFxuICBtZXRhZGF0YSxcbiAgbWltZVR5cGUsXG4gIG1pbkJ5dGVzLFxuICBtaW5HcmFwaGVtZXMsXG4gIG1pbkxlbmd0aCxcbiAgbWluU2l6ZSxcbiAgbWluVmFsdWUsXG4gIG1pbldvcmRzLFxuICBtdWx0aXBsZU9mLFxuICBuYW4sXG4gIG5hbm9pZCxcbiAgbmV2ZXIsXG4gIG5vbkVtcHR5LFxuICBub25OdWxsYWJsZSxcbiAgbm9uTnVsbGFibGVBc3luYyxcbiAgbm9uTnVsbGlzaCxcbiAgbm9uTnVsbGlzaEFzeW5jLFxuICBub25PcHRpb25hbCxcbiAgbm9uT3B0aW9uYWxBc3luYyxcbiAgbm9ybWFsaXplLFxuICBub3RCeXRlcyxcbiAgbm90R3JhcGhlbWVzLFxuICBub3RMZW5ndGgsXG4gIG5vdFNpemUsXG4gIG5vdFZhbHVlLFxuICBub3RWYWx1ZXMsXG4gIG5vdFdvcmRzLFxuICBudWxsXyBhcyBudWxsLFxuICBudWxsXyxcbiAgbnVsbGFibGUsXG4gIG51bGxhYmxlQXN5bmMsXG4gIG51bGxpc2gsXG4gIG51bGxpc2hBc3luYyxcbiAgbnVtYmVyLFxuICBvYmplY3QsXG4gIG9iamVjdEFzeW5jLFxuICBvYmplY3RXaXRoUmVzdCxcbiAgb2JqZWN0V2l0aFJlc3RBc3luYyxcbiAgb2N0YWwsXG4gIG9taXQsXG4gIG9wdGlvbmFsLFxuICBvcHRpb25hbEFzeW5jLFxuICBwYXJzZSxcbiAgcGFyc2VBc3luYyxcbiAgcGFyc2VyLFxuICBwYXJzZXJBc3luYyxcbiAgcGFydGlhbCxcbiAgcGFydGlhbEFzeW5jLFxuICBwYXJ0aWFsQ2hlY2ssXG4gIHBhcnRpYWxDaGVja0FzeW5jLFxuICBwaWNrLFxuICBwaWNrbGlzdCxcbiAgcGlwZSxcbiAgcGlwZUFzeW5jLFxuICBwcm9taXNlLFxuICByYXdDaGVjayxcbiAgcmF3Q2hlY2tBc3luYyxcbiAgcmF3VHJhbnNmb3JtLFxuICByYXdUcmFuc2Zvcm1Bc3luYyxcbiAgcmVhZG9ubHksXG4gIHJlY29yZCxcbiAgcmVjb3JkQXN5bmMsXG4gIHJlZHVjZUl0ZW1zLFxuICByZWdleCxcbiAgcmVxdWlyZWQsXG4gIHJlcXVpcmVkQXN5bmMsXG4gIHJldHVybnMsXG4gIHJldHVybnNBc3luYyxcbiAgcmZjRW1haWwsXG4gIHNhZmVJbnRlZ2VyLFxuICBzYWZlUGFyc2UsXG4gIHNhZmVQYXJzZUFzeW5jLFxuICBzYWZlUGFyc2VyLFxuICBzYWZlUGFyc2VyQXN5bmMsXG4gIHNldCxcbiAgc2V0QXN5bmMsXG4gIHNldEdsb2JhbENvbmZpZyxcbiAgc2V0R2xvYmFsTWVzc2FnZSxcbiAgc2V0U2NoZW1hTWVzc2FnZSxcbiAgc2V0U3BlY2lmaWNNZXNzYWdlLFxuICBzaXplLFxuICBzbHVnLFxuICBzb21lSXRlbSxcbiAgc29ydEl0ZW1zLFxuICBzdGFydHNXaXRoLFxuICBzdHJpY3RPYmplY3QsXG4gIHN0cmljdE9iamVjdEFzeW5jLFxuICBzdHJpY3RUdXBsZSxcbiAgc3RyaWN0VHVwbGVBc3luYyxcbiAgc3RyaW5nLFxuICBzeW1ib2wsXG4gIHRpdGxlLFxuICB0b0xvd2VyQ2FzZSxcbiAgdG9NYXhWYWx1ZSxcbiAgdG9NaW5WYWx1ZSxcbiAgdG9VcHBlckNhc2UsXG4gIHRyYW5zZm9ybSxcbiAgdHJhbnNmb3JtQXN5bmMsXG4gIHRyaW0sXG4gIHRyaW1FbmQsXG4gIHRyaW1TdGFydCxcbiAgdHVwbGUsXG4gIHR1cGxlQXN5bmMsXG4gIHR1cGxlV2l0aFJlc3QsXG4gIHR1cGxlV2l0aFJlc3RBc3luYyxcbiAgdWxpZCxcbiAgdW5kZWZpbmVkXyBhcyB1bmRlZmluZWQsXG4gIHVuZGVmaW5lZF8sXG4gIHVuZGVmaW5lZGFibGUsXG4gIHVuZGVmaW5lZGFibGVBc3luYyxcbiAgdW5pb24sXG4gIHVuaW9uQXN5bmMsXG4gIHVua25vd24sXG4gIHVud3JhcCxcbiAgdXJsLFxuICB1dWlkLFxuICB2YWx1ZSxcbiAgdmFsdWVzLFxuICB2YXJpYW50LFxuICB2YXJpYW50QXN5bmMsXG4gIHZvaWRfIGFzIHZvaWQsXG4gIHZvaWRfLFxuICB3b3Jkc1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/valibot/dist/index.js\n");

/***/ })

};
;